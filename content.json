{"pages":[],"posts":[{"title":"NOI2007 社交网络","text":"题目大意： 一个无向连通图，Cs,tC_{s,t}C​s,t​​表示从s到t的最短路条数，Cs,t(v)C_{s,t}(v)C​s,t​​(v)表示经过v从s到t的最短路条数。 对于每个点v，求出l(v)=∑s≠v,t≠vCs,t(v)Cs,tl(v)=\\sum \\limits_{s\\neq v,t \\neq v}\\frac{C_{s,t}(v)}{C_{s,t}}l(v)=​s≠v,t≠v​∑​​​C​s,t​​​​C​s,t​​(v)​​(s到t的最短路上经过v) 题解： 由于点数小于100，直接对于每个点SPFA完了之后暴力计算 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #define N 220000 using namespace std; int tot,h[N],Next[N],w[N],v[N]; long long n,m,p[120],q[N],d[120][120],f[120][120],behind[N]; int add(int x,int y,int z){ tot++; Next[tot]=h[x]; v[tot]=y; w[tot]=z; h[x]=tot; } int l[120]; int spfa(long long d[],long long f[],int s){ for(int i=0;i&lt;=n;i++)d[i]=0x7fffffff; int head=0,tail=1; d[s]=0; p[s]=1; q[1]=s; p[s]=1; memset(p,0,sizeof(p)); while(head&lt;tail){ int now=q[++head]; for(int i=h[now];i;i=Next[i]){ if(d[now]+w[i]&lt;d[v[i]]){ d[v[i]]=d[now]+w[i]; if(p[v[i]]==0){ q[++tail]=v[i]; p[v[i]]=1; } } } p[now]=0; } memset(l,0,sizeof(l)); for(int i=1;i&lt;=2*m;i++)if(d[v[behind[i]]]+w[i]==d[v[i]])l[v[i]]++; f[s]=1; q[1]=s; p[s]=1; head=0,tail=1; memset(p,0,sizeof(p)); while(head&lt;tail){ int now=q[++head]; for(int i=h[now];i;i=Next[i]){ if(d[v[i]]==d[now]+w[i]){ f[v[i]]+=f[now]; l[v[i]]--; if(l[v[i]]==0)q[++tail]=v[i]; } } } } double cal(int x){ double ans=0; for(int i=1;i&lt;=n;i++){ if(x==i)continue; for(int j=1;j&lt;=n;j++){ if(x==j)continue; if(d[x][i]+d[x][j]&gt;d[i][j])continue; ans+=((double)f[x][i]+0.0)*f[x][j]/f[i][j]; } } return ans; } int main(){ freopen(&quot;1.in&quot;,&quot;r&quot;,stdin); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=m;i++){ int x,y,z; scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z); add(x,y,z);behind[tot]=tot+1; add(y,x,z);behind[tot]=tot-1; } for(int i=1;i&lt;=n;i++)spfa(d[i],f[i],i); for(int i=1;i&lt;=n;i++)printf(&quot;%.7lf\\n&quot;,cal(i)); }","path":"2018/06/27/NOI2007-社交网络/"},{"title":"BZOJ2042 陶陶的难题II","text":"题目大意： 树上每个节点有x,y,q,p四个值，每次查询一条链上两个节点iii和jjj使得yi+qjxi+pj\\frac{y_i+q_j}{x_i+p_j}​x​i​​+p​j​​​​y​i​​+q​j​​​​最大，输出这个最大值。 题解： 二分答案kkk,判定yi+qjxi+pj&gt;k\\frac{y_i+q_j}{x_i+p_j}&gt;k​x​i​​+p​j​​​​y​i​​+q​j​​​​&gt;k yi+qj−k(xi+pj)&gt;0y_i+q_j-k(x_i+p_j)&gt;0y​i​​+q​j​​−k(x​i​​+p​j​​)&gt;0 yi−kxi+qj−kpj&gt;0y_i-kx_i+q_j-kp_j&gt;0y​i​​−kx​i​​+q​j​​−kp​j​​&gt;0 既寻找yi−kxiy_i-kx_iy​i​​−kx​i​​和qj−kpjq_j-kp_jq​j​​−kp​j​​的最大值 两组的查询方法一样，将xix_ix​i​​设为横坐标，yiy_iy​i​​设为纵坐标，维护一条链上的凸包，做一条斜率为k的直线，然后三分取得最大值，链上的凸包维护用树链剖分实现，每个线段树的节点都用vector来储存凸包。 时间复杂度：O(nlog4n)O(n\\log^4n)O(nlog​4​​n) 二分答案一个logloglog，树链剖分两个logloglog，在凸包上三分一个logloglog（如果有n2n^2n​2​​的做法可能能直接碾过去）。 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #define N 220000 #define eps (double)1e-10 using namespace std; int Next[N],v[N],h[N],siz[N],top[N],son[N],st[N],dep[N],f[N],ed[N],tot,cnt,n,m; struct illyasviel{ double x,y; }; double slope(illyasviel x,illyasviel y,illyasviel z){ return (y.y-x.y)*(z.x-x.x)&lt;(z.y-x.y)*(y.x-x.x); } struct node{ vector&lt;illyasviel&gt;a; int insert(illyasviel x){a.push_back(x);} int add(illyasviel x){ // if(fabs(x.x-a[]) if(a.size()==0){ a.push_back(x); return 0; } if(x.y&lt;=a[a.size()-1].y+eps)return 0; int o=a.size()-1; while(o&gt;=1&amp;&amp;slope(a[o-1],a[o],x)) a.pop_back(),o--; a.push_back(x); } double get(int x,double d){ return a[x].y-a[x].x*d; } double query(double d){ int l=0,r=a.size()-1; double ans=-100000000; // for(int i=0;i&lt;r;i++)printf(&quot;%.3lf %.3lf\\n&quot;,a[i].x,a[i].y); while(r-l&gt;3){ int ml=(l+r+l)/3,mr=(l+r+r)/3; if(get(ml,d)&lt;get(mr,d))l=ml; else r=mr; } for(int i=l;i&lt;=r;i++) ans=max(ans,get(i,d)); return ans; } }; node merge(node &amp;x,node &amp;y){ node ans; ans.a.clear(); int i=0,j=0; while(i&lt;x.a.size()||j&lt;y.a.size()){ if(i&lt;x.a.size()&amp;&amp;j&lt;y.a.size()){ if(x.a[i].x&lt;y.a[j].x){ ans.add(x.a[i]); i++; } else{ ans.add(y.a[j]); j++; } continue; } if(i&lt;x.a.size())ans.add(x.a[i]),i++; if(j&lt;y.a.size())ans.add(y.a[j]),j++; } return ans; } struct seg{ node a[N*4]; illyasviel s[N*4]; int build(int i,int l,int r){ if(l==r){ a[i].insert(s[ed[l]]); return 0; } int mid=(l+r)/2; build(i*2,l,mid); build(i*2+1,mid+1,r); a[i]=merge(a[i*2],a[i*2+1]); } double query(int i,int l,int r,int x,int y,double d){ if(x&lt;=l&amp;&amp;r&lt;=y)return a[i].query(d); int mid=(l+r)/2; double ans=-1000000000000.0; if(mid&gt;=x)ans=max(ans,query(i*2,l,mid,x,y,d)); if(mid&lt;y)ans=max(ans,query(i*2+1,mid+1,r,x,y,d)); return ans; } }s1,s2; int add(int x,int y){ tot++; Next[tot]=h[x]; v[tot]=y; h[x]=tot; } int dfs(int x,int fa){ siz[x]++; f[x]=fa; dep[x]=dep[fa]+1; for(int i=h[x];i;i=Next[i]){ if(v[i]==fa)continue; dfs(v[i],x); siz[x]+=siz[v[i]]; if(siz[v[i]]&gt;siz[son[x]])son[x]=v[i]; } } int dfs1(int x,int fa){ st[x]=++cnt; if(son[x])top[son[x]]=top[x]; if(son[x])dfs1(son[x],x); for(int i=h[x];i;i=Next[i]){ if(v[i]==fa||v[i]==son[x])continue; top[v[i]]=v[i]; dfs1(v[i],x); } } int lca(int x,int y){ while(top[x]!=top[y]){ if(dep[top[x]]&lt;dep[top[y]])y=f[top[y]]; else x=f[top[x]]; } return dep[x]&lt;dep[y]?x:y; } illyasviel query_illyasviel(int x,int y,double d){ illyasviel ans; ans.x=-100000000000000.0; ans.y=-100000000000000.0; if(dep[x]&lt;dep[y])swap(x,y); int r=st[x]; while(dep[top[x]]&gt;dep[y]){ ans.x=max(ans.x,s1.query(1,1,n,st[top[x]],st[x],d)); ans.y=max(ans.y,s2.query(1,1,n,st[top[x]],st[x],d)); // printf(&quot;%d %d\\n&quot;,st[top[x]],st[x]); x=f[top[x]]; } ans.x=max(ans.x,s1.query(1,1,n,st[y],st[x],d)); ans.y=max(ans.y,s2.query(1,1,n,st[y],st[x],d)); //printf(&quot;%d %d\\n&quot;,st[y],st[x]); return ans; } double check(double d,int x,int y){ int z=lca(x,y); illyasviel a,b; a=query_illyasviel(x,z,d); b=query_illyasviel(y,z,d); return max(a.x,b.x)+max(a.y,b.y); } double query(int x,int y){ double l=0.0,r=2000000.0; // printf(&quot;%.5lf\\n&quot;,check((double)4.85,x,y)); while(r-l&gt;1e-5){ double mid=(l+r)/2; if(check(mid,x,y)&gt;eps)l=mid; else r=mid; } return l+1e-6; } int main(){ scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++)scanf(&quot;%lf&quot;,&amp;s1.s[i].x); for(int i=1;i&lt;=n;i++)scanf(&quot;%lf&quot;,&amp;s1.s[i].y); for(int i=1;i&lt;=n;i++)scanf(&quot;%lf&quot;,&amp;s2.s[i].x); for(int i=1;i&lt;=n;i++)scanf(&quot;%lf&quot;,&amp;s2.s[i].y); for(int i=1;i&lt;n;i++){ int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); add(x,y); add(y,x); } dfs(1,0); top[1]=1; dfs1(1,0); for(int i=1;i&lt;=n;i++)ed[st[i]]=i; s1.build(1,1,n); s2.build(1,1,n); scanf(&quot;%d&quot;,&amp;m); for(int i=1;i&lt;=m;i++){ int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); printf(&quot;%.5lf\\n&quot;,query(x,y)); } }","path":"2018/06/26/BZOJ2402-陶陶的难题II/"},{"title":"斜率优化","text":"斜率优化 作用： 将某些复杂度不对的dp方程降一个维度，譬如O（n^2）的dp方程，若其满足决策单调性，既可通过斜率优化对其进行降维打击，让它强行变成O（n）的。 #决策单调性： 若对于fif_if​i​​来说，选择k这个决策是最优的，那么对于fi+1f_{i+1}f​i+1​​到fnf_nf​n​​来说，选择k之前的决策不会比选择k更优。例如：若f具有决策单调性fi+1f_{i+1}f​i+1​​的决策一定是k或在k后面的决策。 【证明决策单调性】： 【数学归纳法】： 设fi=min(fj+ai−aj)f_i=min(f_j+a_i-a_j)f​i​​=min(f​j​​+a​i​​−a​j​​) 假设有两个决策j和k,k&gt;j且k优于j fk+ai−ak&lt;fj+ai−ajf_k+a_i-a_k&lt;f_j+a_i-a_jf​k​​+a​i​​−a​k​​&lt;f​j​​+a​i​​−a​j​​ fk−ak&lt;fj−ajf_k-a_k&lt;f_j-a_jf​k​​−a​k​​&lt;f​j​​−a​j​​ 那么对于fi+1f_{i+1}f​i+1​​来说选择kkk即fi+1=fk+ai+1−akf_{i+1}=f_k+a_{i+1}-a_kf​i+1​​=f​k​​+a​i+1​​−a​k​​ 而选择jjj的话即fi+1=fj+ai+1−ajf_{i+1}=f_j+a_{i+1}-a_jf​i+1​​=f​j​​+a​i+1​​−a​j​​ 因为第444行的式子，对于fi+1f_{i+1}f​i+1​​选择k明显比选择j更优，同理fi+2f_i+2f​i​​+2可通过fi+1f_{i+1}f​i+1​​得到，那么，可既可说这个dp方程具有决策单调性。 斜率优化： 举例子说明总是比较直观的，下面我们来看一道例题。 【题目】: 现在我们有一个序列aaa，我们能把序列aaa切成若干段，对于在iii和jjj被断开的一段序列，既ai..ja_{i..j}a​i..j​​，我们可以得到一个分数∑k=ijak\\sum_{k=i}^j a_k∑​k=i​j​​a​k​​。我们在i位置切割一次，就会得到cic_ic​i​​的分数。那么对于整个序列a，我们希望它的总分最小，求这个分数和。 【n2n^2n​2​​做法】: 显然，我们能得到一个效率为n2n^2n​2​​的dp方程 我们先设 sumk=∑i=1kaisum_k=\\sum_{i=1}^ka_i sum​k​​=​i=1​∑​k​​a​i​​ fi=min(fj+(simi−sumj)2+ci)f_i=min(f_j+(sim_i-sum_j)^2+c_i) f​i​​=min(f​j​​+(sim​i​​−sum​j​​)​2​​+c​i​​) 若n≤105n\\leq10^5n≤10​5​​那么这个复杂度不能令人满意，我们就要接着对他进行一些处理。 【证明决策单调性】 若k&gt;jk&gt; jk&gt;j且kkk优于jjj fj+(sumi−sumj)2+ci&gt;fk+(sumi−sumk)2+cif_j+(sum_i-sum_j)^2+c_i&gt;f_k+(sum_i-sum_k)^2+c_i f​j​​+(sum​i​​−sum​j​​)​2​​+c​i​​&gt;f​k​​+(sum​i​​−sum​k​​)​2​​+c​i​​ fj+sumi2−2×sumi×sumj+sumj2+ci&gt;fk+sumi2−2×sumi×sumk+sumk2+cif_j+sum_i^2-2\\times sum_i\\times sum_j+sum_j^2+c_i&gt;f_k+sum_i^2-2\\times sum_i\\times sum_k+sum_k^2+c_i f​j​​+sum​i​2​​−2×sum​i​​×sum​j​​+sum​j​2​​+c​i​​&gt;f​k​​+sum​i​2​​−2×sum​i​​×sum​k​​+sum​k​2​​+c​i​​ fj−2×sumi×sumj+sumj2&gt;fk−2×sumi∗sumk+sumk2f_j-2\\times sum_i\\times sum_j+sum_j^2&gt;f_k-2\\times sum_i*sum_k+sum_k^2 f​j​​−2×sum​i​​×sum​j​​+sum​j​2​​&gt;f​k​​−2×sum​i​​∗sum​k​​+sum​k​2​​ 那么对于fi+1f_{i+1}f​i+1​​来说: 选择j为决策既：fi+1=fj+(sumi+1−sumj)2+ci+1f_{i+1}=f_j+(sum_{i+1}-sum_j)^2+c_{i+1}f​i+1​​=f​j​​+(sum​i+1​​−sum​j​​)​2​​+c​i+1​​ 选择k为决策既：fi+1=fk+(sumi+1−sumk)2+ci+1f_{i+1}=f_k+(sum_{i+1}-sum_k)^2+c_{i+1}f​i+1​​=f​k​​+(sum​i+1​​−sum​k​​)​2​​+c​i+1​​ 从上面的式子可以得到选择k优于选择j（不信的话可以自己展开） 那么可以证明这个dp方程式具有决策单调性的。 【推导斜率式】 fj−2×sumi×sumj+sumj2&gt;fk−2×sumi∗sumk+sumk2f_j-2\\times sum_i\\times sum_j+sum_j^2&gt;f_k-2\\times sum_i*sum_k+sum_k^2 f​j​​−2×sum​i​​×sum​j​​+sum​j​2​​&gt;f​k​​−2×sum​i​​∗sum​k​​+sum​k​2​​ 从这条式子继续 fj−fk+sumj2−sumk2&gt;2×sumi∗(sumj−sumk)f_j-f_k+sum_j^2-sum_k^2&gt;2\\times sum_i*(sum_j-sum_k) f​j​​−f​k​​+sum​j​2​​−sum​k​2​​&gt;2×sum​i​​∗(sum​j​​−sum​k​​) fj−fk+sumj2−sumk2sumj−sumk&gt;2∗sumi\\frac{f_j-f_k+sum_j^2-sum_k^2}{sum_j-sum_k}&gt;2*sum_i ​sum​j​​−sum​k​​​​f​j​​−f​k​​+sum​j​2​​−sum​k​2​​​​&gt;2∗sum​i​​ 根据这条式子的定义，我们可以得到，对于k&gt;jk&gt;jk&gt;j，只有在满足上面式子的情况下才会k比j优 我们把(fj+sumj2,sumj)(f_j+sum_j^2,sum_j)(f​j​​+sum​j​2​​,sum​j​​)和(fk+sumk2,sumk)(f_k+sum_k^2,sum_k)(f​k​​+sum​k​2​​,sum​k​​)分别看做坐标系上面的点，那么小于号左边的式子的含义恰好是这两个点之间的斜率。 现在我们假设找到了一个点(x,y)对于fif_if​i​​最优。我们在x点上画一条斜率为2∗sumi2*sum_i2∗sum​i​​的斜线，那么，对于其他所有点，都必须在这条斜线上方。 证明：若(a,b)(a,b)(a,b)在斜线下方，且a&lt;xa&lt;xa&lt;x那么根据上面的式子(a,b)(x,y)(a,b)(x,y)(a,b)(x,y)之间的斜率会大于2×sumi2\\times sum_i2×sum​i​​并且a&lt;xa&lt;xa&lt;x，那么(x,y)则不是最优点。若(a,b)在斜线下方，且a&gt;xa&gt;xa&gt;x那么根据上面的式子(a,b)(x,y)(a,b)(x,y)(a,b)(x,y)之间的斜率会小于2×sumi2\\times sum_i2×sum​i​​并且a&gt;xa&gt;xa&gt;x，那么(x,y)则不是最优点。 换句话说，对于fif_if​i​​来说，最优解x是斜率k=2∗sumik=2*sum_ik=2∗sum​i​​从下往上扫扫到点集里最优的那个点。 显然，我们可以得到一个很显然的结论，那就是这个最优解x在下凸壳上。那么我们可以通过一个队列来维护凸包，并且根据决策单调性，还有fj−fk+sumj2−sumk2sumj−sumk&gt;2∗sumi\\frac{f_j-f_k+sum_j^2-sum_k^2}{sum_j-sum_k}&gt;2*sum_i​sum​j​​−sum​k​​​​f​j​​−f​k​​+sum​j​2​​−sum​k​2​​​​&gt;2∗sum​i​​这条斜率式，我们可以每次比对下凸壳上相邻的两个点（也就是队首元素），若队列中第二个元素比队首元素优，那么我们可以删除队首元素（决策单调性，队首元素再也用不到）。 我们注意到，对于点i来说，他的横坐标是sumisum_isum​i​​,因为sumisum_isum​i​​是前缀和，是递增的，所以加入的点的横坐标也是递增的，那么对于每个点，我们只要把它加入维护凸包的那个队列就好了。 【某些不得不说的东西】： 最后我们推出来的式子一般都是长这样： x与j和k有关，y与j和k有关并且递增 xy\\frac{x}{y}​y​​x​​&lt;或&gt;只与i有关并且递增的常数 如果右边的与i有关的常数不是递增的，那意味着我们要扫的答案的斜率不是递增的，那么决策单调性就会消失，我们就要用平衡树或者三分去维护。所以一般，正常，好写的斜率优化最后推出来的式子一般都形如上面那条√","path":"2018/06/24/斜率优化/"},{"title":"杜教筛","text":"杜教筛 ​ 我不会什么狄利克雷卷积，但同我反演只用∑d∣nμ(d)=(n==1)\\sum_{d|n}\\mu(d)=(n==1)∑​d∣n​​μ(d)=(n==1)这条式子一样，我觉得杜教筛也是相似的。 例题1： ​ ∑i=1nμ(i)\\sum_{i=1}^{n}\\mu(i)∑​i=1​n​​μ(i)范围：n≤1010n\\le10^{10}n≤10​10​​ 题解： ​ 引入式子∑d∣nμ(d)==(n==1)\\sum_{d|n}\\mu(d)==(n==1)∑​d∣n​​μ(d)==(n==1) ：这条以及后文引入的两条式子可在莫比乌斯反演那篇博文里看到证明 ​ 考虑μ(n)\\mu(n)μ(n)：μ(n)=(n==1)−∑d∣n&amp;d&lt;nμ(d)\\mu(n)=(n==1)-\\sum_{d|n\\&amp;d&lt;n}\\mu(d)μ(n)=(n==1)−∑​d∣n&amp;d&lt;n​​μ(d) ​ 那么将μ(n)\\mu(n)μ(n)代入原式 ​ ∑i=1nμ(i)\\sum_{i=1}^n\\mu(i)∑​i=1​n​​μ(i) ​ =∑i=1n((i==1)−∑d∣i&amp;d&lt;iμ(d))=\\sum_{i=1}^n((i==1)-\\sum_{d|i\\&amp;d&lt;i}\\mu(d))=∑​i=1​n​​((i==1)−∑​d∣i&amp;d&lt;i​​μ(d)) ​ =1−∑i=1n∑d∣i&amp;d&lt;iμ(d)=1-\\sum_{i=1}^n\\sum_{d|i\\&amp;d&lt;i } \\mu(d)=1−∑​i=1​n​​∑​d∣i&amp;d&lt;i​​μ(d) ​ 那么，对于μ(d)\\mu(d)μ(d)来说，它只有在d|i且d ​ 换句话说，μ(d)\\mu(d)μ(d)会在xd≤nxd\\le nxd≤n时被计算上（x&gt;1x&gt;1x&gt;1） ​ 那么我们枚举xxx ​ 原式既等于 ​ =1−∑x=2n∑xd&lt;=nμ(d)=1-\\sum_{x=2}^n\\sum_{xd&lt;=n}\\mu(d)=1−∑​x=2​n​​∑​xd&lt;=n​​μ(d) ​ =1−∑x=2n∑d=1⌊nx⌋μ(d)=1-\\sum_{x=2}^n\\sum_{d=1}^{\\lfloor\\frac{n}{x}\\rfloor}\\mu(d)=1−∑​x=2​n​​∑​d=1​⌊​x​​n​​⌋​​μ(d) ​ 稍微换一下符号 ​ =1−∑x=2n∑i=1⌊nx⌋μ(i)=1-\\sum_{x=2}^{n}\\sum_{i=1}^{\\lfloor\\frac{n}{x}\\rfloor}\\mu(i)=1−∑​x=2​n​​∑​i=1​⌊​x​​n​​⌋​​μ(i) ​ 然后我们发现 ​ woc右边那一块式子怎么那么熟悉（∑i=1⌊nx⌋μ(i)\\sum_{i=1}^{\\lfloor\\frac{n}{x}\\rfloor}\\mu(i)∑​i=1​⌊​x​​n​​⌋​​μ(i)） ​ 就好像……，就好像最开始要求的那样 ​ 那么我们设最开始的为一个函数： f(n)=∑i=1nμ(i)=1−∑x=2n∑i=1⌊nx⌋μ(i)=1−∑x=2nf(⌊nx⌋)f(n)=\\sum_{i=1}^n\\mu(i)=1-\\sum_{x=2}^{n}\\sum_{i=1}^{\\lfloor\\frac{n}{x}\\rfloor}\\mu(i)=1-\\sum_{x=2}^nf(\\lfloor\\frac{n}{x}\\rfloor)f(n)=∑​i=1​n​​μ(i)=1−∑​x=2​n​​∑​i=1​⌊​x​​n​​⌋​​μ(i)=1−∑​x=2​n​​f(⌊​x​​n​​⌋) ​ 那么，总共有根号不同的对于每个f(n)f(n)f(n)来说，我们最多要求根号级别的f(⌊nx⌋)f(\\lfloor\\frac{n}{x}\\rfloor)f(⌊​x​​n​​⌋) ​ 预处理前n23n^{\\frac{2}{3}}n​​3​​2​​​​的fff,然后记忆化搜索即可（后面的f的函数值用哈希表来存（或者map，不过多一个log）） 例题2： ​ Φ(i)=∑i=1nφ(i)\\Phi(i)=\\sum_{i=1}^{n}\\varphi(i)Φ(i)=∑​i=1​n​​φ(i)范围：n≤1010n\\le10^{10}n≤10​10​​ 题解： 引入： ∑d∣nφ(d)=n\\sum_{d|n}\\varphi(d)=n∑​d∣n​​φ(d)=n ​ φ(n)=n−∑d∣n&amp;d&lt;nφ(d)\\varphi(n)=n-\\sum_{d|n\\&amp;d&lt;n}\\varphi(d)φ(n)=n−∑​d∣n&amp;d&lt;n​​φ(d) ​ 原式=∑i=1n(i−∑d∣ni&amp;d&lt;iφ(i))\\sum_{i=1}^n(i-\\sum_{d|ni\\&amp;d&lt;i}\\varphi(i))∑​i=1​n​​(i−∑​d∣ni&amp;d&lt;i​​φ(i)) ​ 枚举dx对数 Φ(n)=n×(n+1)2−∑x=2n∑dx&lt;=nφ(d)\\Phi(n)=\\frac{n\\times(n+1)}{2}-\\sum_{x=2}^n\\sum_{dx&lt;=n}\\varphi(d) Φ(n)=​2​​n×(n+1)​​−​x=2​∑​n​​​dx&lt;=n​∑​​φ(d) =n×(n+1)2−∑x=2n∑d=1⌊nx⌋φ(d)=\\frac{n\\times(n+1)}{2}-\\sum_{x=2}^n\\sum_{d=1}^{\\lfloor\\frac{n}{x}\\rfloor}\\varphi(d) =​2​​n×(n+1)​​−​x=2​∑​n​​​d=1​∑​⌊​x​​n​​⌋​​φ(d) =n×(n+1)2−∑x=2n∑i=1⌊nx⌋φ(i)=\\frac{n\\times(n+1)}{2}-\\sum_{x=2}^n\\sum_{i=1}^{\\lfloor\\frac{n}{x}\\rfloor}\\varphi(i) =​2​​n×(n+1)​​−​x=2​∑​n​​​i=1​∑​⌊​x​​n​​⌋​​φ(i) =n×(n+1)2−∑x=2n∑i=1⌊nx⌋φ(i)=\\frac{n\\times(n+1)}{2}-\\sum_{x=2}^n\\sum_{i=1}^{\\lfloor\\frac{n}{x}\\rfloor}\\varphi(i) =​2​​n×(n+1)​​−​x=2​∑​n​​​i=1​∑​⌊​x​​n​​⌋​​φ(i) =n×(n+1)2−∑x=2nΦ(⌊nx⌋)=\\frac{n\\times(n+1)}{2}-\\sum_{x=2}^n\\Phi(\\lfloor\\frac{n}{x}\\rfloor) =​2​​n×(n+1)​​−​x=2​∑​n​​Φ(⌊​x​​n​​⌋) ​ 记忆化搜索即可 复杂度分析：不会，大概调一下预处理的参数，别的博客上面证明是O(n23)O(n^{\\frac{2}{3}})O(n​​3​​2​​​​)左右。 核心：乱推式子+记忆化搜索 筛phi的前缀和的模板 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;map&gt; #define MOD (1000000007) #define N 2500000 using namespace std; int p[N],prime[N],phi[N],tot; long long f[N]; map&lt;long long,long long&gt;l; int pre(){ phi[1]=1; for(int i=2;i&lt;=N-10;i++){ if(p[i]==0){ prime[++tot]=i; phi[i]=i-1; } for(int j=1;j&lt;=tot&amp;&amp;i*prime[j]&lt;=N-10;j++){ p[i*prime[j]]=1; phi[iprime[j]]=phi[i]phi[prime[j]]; if(i%prime[j]==0){ phi[iprime[j]]=phi[i]prime[j]; break; } } } } long long dfs(long long x){ if(x&lt;=N-10)return f[x]; if(l[x]!=0)return l[x]; long long ans=0; for(long long i=2;i&lt;=x;i++){ long long j=x/(x/i),k=(x/i); (ans=ans+dfs(k)*(j-i+1))%=MOD; i=j; } int k=x%MOD; l[x]=(1LLk(k+1)/2-ans%MOD)%MOD; return l[x]; } int main(){ pre(); long long n; scanf(&quot;%lld&quot;,&amp;n); for(long long i=1;i&lt;=N-10;i++)(f[i]=0LL+f[i-1]+phi[i])%MOD; printf(&quot;%lld&quot;,dfs(n)%MOD); }","path":"2018/06/24/杜教筛/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post $ hexo new &quot;My New Post&quot; More info: Writing Run server $ hexo server More info: Server Generate static files $ hexo generate More info: Generating Deploy to remote sites $ hexo deploy More info: Deployment","path":"2018/06/23/hello-world/"}]}