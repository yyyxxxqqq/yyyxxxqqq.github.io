{"pages":[],"posts":[{"title":"2018暑假计划","text":"总进度：（18/300） 总错误： MLE:1 RE:1 2018-7-16 大包子的完美组合 等差子序列 普通平衡树 训练赛： gcd(100/100) 次小生成树 tree(100/100) k个串 kstring(10/100)失分原因：NM打反导致线段树节点不够。 场上得分：(210/300) 2018-7-15 JSOI2008 火星人prefix Bracket zuma 训练赛： 兔子与樱花(100/100) 矩阵乘法(100/100) 聪聪可可(100/100) 场上得分(300/300) 2018-7-14 rank sequence string 训练赛： game with probability(100/100) 病毒(100/100) Count on a tree(0/100)失分原因:MLE 场上得分(200/300)","path":"2018/07/16/暑假计划/"},{"title":"大包子的完美组合","text":"题目大意： 大包子的公司有n个人，编号分别为1至n。年底，大包子将要举办一场舞会，大包子要从中选出一些人参加这个舞会。 如果选出的这些人中，编号两两互质，我们就认为这是一个完美组合。比如 5 个人的公司中，3, 4, 5这三个人可以组成完美组合。请计算n个人可以选出的完美组合的方案数。 由于答案很大，你需要把答案对109+710^9+710​9​​+7取模。 题解： 首先，我们先把n\\sqrt{n}√​n​​​的素数筛出来，只有16个。 首先我们把1到3000根据该数的最大质因子排序。 我们对小于n\\sqrt{n}√​n​​​ 的素数做状压 DP ，每一位存当前该素数是否被取用过。 对于大于 n\\sqrt{n}√​n​​​的素数，我们发现同一个数中不可能存在两个大于n\\sqrt{n}√​n​​​的因子，因此我们枚举每个素数，枚举最大质因子是这个素数的数，做一次状压 DP ，再记录一维表示这个大素数是否被取用。 将最终答案减去空集。 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;algorithm&gt; #define P 1000000007 #define M 3200 #define K 16 using namespace std; int prime[K]={2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53}; int n; int f[2][1&lt;&lt;K][2]; struct node{int max,sc;}a[M]; int cmp(node x,node y){ if(x.max!=y.max) return x.max&lt;y.max; if(x.sc!=y.sc) return x.sc&lt;y.sc; } int cut(int x){ int ans=0; for(int j=0;j&lt;K;j++) if(x%prime[j]==0) ans|=1&lt;&lt;j; return ans; } int main(void){ scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++){ a[i].max=i; a[i].sc=1; for(int j=0;j&lt;K;j++) while(a[i].max%prime[j]==0) {a[i].max/=prime[j];a[i].sc*=prime[j];} } sort(a+1,a+n+1,cmp); f[0][0][0]=1; int p=0; for(int i=1;i&lt;=n;i++){ if(a[i].max!=a[i-1].max) for(int j=0;j&lt;1&lt;&lt;K;j++) (f[p][j][0]+=f[p][j][1])%=P,f[p][j][1]=0; p^=1; for(int j=0;j&lt;1&lt;&lt;K;j++) f[p][j][0]=f[p^1][j][0],f[p][j][1]=f[p^1][j][1]; int is=a[i].max&gt;1; int tmp=cut(a[i].sc); for(int j=(1&lt;&lt;K)-1;j&gt;=0;j--) if( f[p^1][j][0]&amp;&amp;!(j&amp;tmp) ) (f[p][j|tmp][is]+=f[p^1][j][0])%=P; } int ans=0; for(int i=0;i&lt;1&lt;&lt;K;i++) for(int j=0;j&lt;=1;j++) (ans+=f[p][i][j])%=P; (ans+=P-1)%=P; printf(&quot;%d\\n&quot;,ans); } 原题链接：大包子的完美组合","path":"2018/07/16/大包子的完美组合/"},{"title":"等差子序列","text":"题目大意： 给一个1到N的排列{A_i}，询问是否存在1≤p1&lt;p2&lt;p3&lt;p4&lt;p5&lt;...&lt;pLen≤N(Len≥3)1\\leq p_1&lt;p_2&lt;p_3&lt;p_4&lt;p_5&lt;...&lt;p_{Len}\\leq N (Len\\geq 3)1≤p​1​​&lt;p​2​​&lt;p​3​​&lt;p​4​​&lt;p​5​​&lt;...&lt;p​Len​​≤N(Len≥3)， 使得Ap1,Ap2,Ap3,...ApLenA_{p1},A{p2},A{p3},...A{pLen}A​p1​​,Ap2,Ap3,...ApLen是一个等差序列。 题解： 树状数组维护hash值。 #include&lt;iostream&gt; #include&lt;string.h&gt; #include&lt;stdio.h&gt; #define N 120000 #define P 1000000007 #define lowbit(x) (x&amp;-x) using namespace std; int n,pw[N],a[N]; struct node{ long long a[N]; int add(int x,int b){ for(int i=x;i&lt;=n;i+=lowbit(i))(a[i]+=b)%=P; } long long sum(int x){ long long ans=0; for(int i=x;i&gt;0;i-=lowbit(i))(ans+=a[i])%=P; return ans; } int clear(){ memset(a,0,sizeof(a)); } }L,R; long long power(long long x,int k){ long long ans=1; while(k){ if(k&amp;1)(ans*=x)%=P; (x*=x)%=P; k&gt;&gt;=1; } return ans; } int main(){ int T; pw[0]=1; scanf(&quot;%d&quot;,&amp;T); for(int i=1;i&lt;=N-10;i++)pw[i]=pw[i-1]*2%P; while(T--){ scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++)scanf(&quot;%lld&quot;,&amp;a[i]); bool ans=false; L.clear(); R.clear(); for(int i=1;i&lt;=n;i++){ int o=a[i]; L.add(o,pw[o]); R.add(n-o+1,pw[n-o+1]); if(o&lt;=n/2) if(L.sum(o-1)!=((R.sum(n-o)-R.sum(n-o-o+1))*power(pw[n-o-o+1],P-2)%P+P)%P){ ans=true; break; } if(o&gt;n/2) if(((L.sum(o-1)-L.sum(o-1-(n-o)))*power(pw[o-1-(n-o)],P-2)%P+P)%P!=R.sum(n-o)){ ans=true; break; } } if(ans)printf(&quot;Y\\n&quot;); else printf(&quot;N\\n&quot;); } } 原题链接：等差子序列","path":"2018/07/16/等差子序列/"},{"title":"普通平衡树","text":"题目大意： 1、插入xx数 2、删除xx数（若有多个相同的数，因只删除一个） 3、查询xx数的排名（若有多个相同的数，因输出最小的排名） 4、查询排名为xx的数 5、求xx的前驱（前驱定义为小于xx，且最大的数） 6、求xx的后继（后继定义为大于xx，且最小的数） #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #define lc(x) (ch[x][0]) #define rc(x) (ch[x][1]) #define N 120000 using namespace std; int sum[N],ch[N][2],fa[N],val[N],cnt[N],o; int n,root,tot; int update(int x){ sum[x]=sum[ch[x][0]]+sum[ch[x][1]]+cnt[x]; } int rotate(int x,int a){ int Fa=fa[x]; if(fa[Fa])ch[fa[Fa]][ch[fa[Fa]][1]==Fa]=x; fa[x]=fa[Fa]; fa[Fa]=x; if(ch[x][a])fa[ch[x][a]]=Fa; ch[Fa][a^1]=ch[x][a]; ch[x][a]=Fa; update(Fa); update(x); } int splay(int x,int y){ while(fa[x]!=y){ int Fa=fa[x]; if(ch[fa[x]][1]==x){ if(fa[Fa]!=y&amp;&amp;ch[fa[Fa]][1]==Fa)rotate(Fa,0); rotate(x,0); }else{ if(fa[Fa]!=y&amp;&amp;ch[fa[Fa]][0]==Fa)rotate(Fa,1); rotate(x,1); } } if(y==0)root=x; return root; }int insert(int rt,int x,int Fa){ if(!rt){ tot++; val[tot]=x; sum[tot]++; cnt[tot]++; fa[tot]=Fa; o=tot; return tot; } if(x&lt;val[rt])ch[rt][0]=insert(ch[rt][0],x,rt); if(x&gt;val[rt])ch[rt][1]=insert(ch[rt][1],x,rt); if(x==val[rt])cnt[rt]++,o=rt; update(rt); return rt; } int ins(int x){ insert(root,x,0); splay(o,0); } int delet(int rt,int x){ if(x&gt;val[rt])delet(rc(rt),x); if(x&lt;val[rt])delet(lc(rt),x); if(x==val[rt]){ o=rt; if(cnt[rt])cnt[rt]--; } update(rt); } int del(int x){ delet(root,x); if(cnt[o])return 0; splay(o,0); int l=rc(o); int k=lc(o); while(lc(l))l=lc(l); while(rc(k))k=rc(k); splay(k,0); splay(l,k); l=rc(k); while(lc(l))l=lc(l); ch[fa[l]][rc(fa[l])==l]=0; fa[l]=0; } int find(int rt){ int x=ch[rt][0]; while(ch[x][1])x=ch[x][1]; return val[x]; } int kind(int rt){ int x=ch[rt][1]; while(ch[x][0])x=ch[x][0]; return val[x]; } int get(int rt,int x){ if(sum[ch[rt][0]]&lt;x-1&amp;&amp;sum[ch[rt][0]]+cnt[rt]&gt;x-1)return val[rt]; if(sum[ch[rt][0]]&gt;x-1)return get(ch[rt][0],x); if(sum[ch[rt][0]]&lt;x-1)return get(ch[rt][1],x-sum[ch[rt][0]]-cnt[rt]); return val[rt]; } int want(int rt,int x){ if(x&lt;val[rt])return want(ch[rt][0],x); if(x&gt;val[rt])return want(ch[rt][1],x); return rt; } int main(){ scanf(&quot;%d&quot;,&amp;n); int inf=2147483647; ins(inf); ins(-inf); for(int i=1;i&lt;=n;i++){ int type,x; scanf(&quot;%d%d&quot;,&amp;type,&amp;x); if(type==1)ins(x); if(type==2)del(x); if(type==3){ splay(want(root,x),0); printf(&quot;%d\\n&quot;,sum[ch[root][0]]); } if(type==4){ printf(&quot;%d\\n&quot;,get(root,x+1)); } if(type==5){ ins(x); printf(&quot;%d\\n&quot;,find(root)); del(x); } if(type==6){ ins(x); printf(&quot;%d\\n&quot;,kind(root)); del(x); } } } 原题链接：【BZOJ3224】【TYVJ1728】普通平衡树","path":"2018/07/16/splay板子/"},{"title":"k个串 kstring","text":"题目大意： 兔子们在玩k个串的游戏。首先，它们拿出了一个长度为n的数字序列，选出其中的一个连续子串，然后统计其子串中所有数字之和（注意这里重复出现的数字只被统计一次）。 兔子们想知道，在这个数字序列所有连续的子串中，按照以上方式统计其所有数字之和，第k大的和是多少。 题解： 考虑每次加入一个右端点，只有preaipre_{a_{i}}pre​a​i​​​​到i上的值会增加aia_ia​i​​，对于每个右端点维护一颗可持久化线段树，这样我们可以快速得到每个右端点的区间最大值。 然后将每个右端点加入优先队列，(v,l,r,p,x)(x表示当前树根（既哪个右端点），lr表示当前区间，p表示在l到r中的最大值是多少，v表示当前最大值)，每次拔出堆顶然后分裂区间后顶进去，重复k次后就能得到最大值。 失分原因： NM打反，导致线段树节点数不够。 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;map&gt; #include&lt;queue&gt; #define N 120000 #define M 7200000 using namespace std; struct illyasviel{ long long x,y; }v[N]; illyasviel get(long long x,long long y){ illyasviel ans; ans.x=x; ans.y=y; return ans; } illyasviel max(illyasviel x,illyasviel y){ if(x.x==y.x){ if(x.y&lt;y.y)return y; return x; } if(x.x&gt;y.x)return x; return y; } int n,m; int tot,rt[N],lc[M],rc[M]; long long tag[M]; map&lt;int,int&gt;pre; struct node{ long long v,x,l,r,now; friend bool operator &lt; (const node &amp;a,const node &amp;b){return a.v&lt;b.v;} }; node get(long long v,int x,int l,int r,int now){ node ans; ans.v=v; ans.x=x; ans.l=l; ans.r=r; ans.now=now; return ans; } priority_queue&lt;node&gt;q; int build(int l,int r){ int x=++tot;v[x]=get(0,l); if(l==r)return x; int mid=l+r&gt;&gt;1; lc[x]=build(l,mid); rc[x]=build(mid+1,r); return x; } int add(int y,long long p){ int x=++tot; lc[x]=lc[y]; rc[x]=rc[y]; v[x]=v[y]; v[x].x+=p; tag[x]=tag[y]+p; return x; } int pushdown(int x){ lc[x]=add(lc[x],tag[x]); rc[x]=add(rc[x],tag[x]); tag[x]=0; } int insert(int y,int l,int r,int ll,int rr,int p){ if(ll&lt;=l&amp;&amp;r&lt;=rr)return add(y,p); if(tag[y])pushdown(y); int x=++tot;lc[x]=lc[y],rc[x]=rc[y],v[x]=v[y]; int mid=l+r&gt;&gt;1; if(ll&lt;=mid)lc[x]=insert(lc[y],l,mid,ll,rr,p); if(rr&gt;mid)rc[x]=insert(rc[y],mid+1,r,ll,rr,p); v[x]=max(v[lc[x]],v[rc[x]]); return x; } illyasviel query(int x,int l,int r,int ll,int rr){ if(ll&lt;=l&amp;&amp;rr&gt;=r)return v[x]; if(tag[x])pushdown(x); int mid=l+r&gt;&gt;1; illyasviel ans; ans.x=-1e15;ans.y=-1e15; if(ll&lt;=mid)ans=max(ans,query(lc[x],l,mid,ll,rr)); if(rr&gt;mid)ans=max(ans,query(rc[x],mid+1,r,ll,rr)); return ans; } int add(int x,int l,int r){ if(l&gt;r)return 0; illyasviel t=query(x,1,n,l,r); q.push(get(t.x,x,l,r,t.y)); } int main(){ freopen(&quot;1.in&quot;,&quot;r&quot;,stdin); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); rt[0]=build(1,n); for(int i=1;i&lt;=n;i++){ int x; scanf(&quot;%d&quot;,&amp;x); rt[i]=insert(rt[i-1],1,n,pre[x]+1,i,x); pre[x]=i; add(rt[i],1,i); } node x; for(int i=1;i&lt;=m;i++){ x=q.top();q.pop(); add(x.x,x.l,x.now-1); add(x.x,x.now+1,x.r); } printf(&quot;%lld&quot;,x.v); } 原题链接：k个串 kstring","path":"2018/07/16/k个串-kstring/"},{"title":"次小生成树 tree","text":"题目大意： 求一个严格的次小生成树。 题解： 先求出最小生成树，然后对于每一条非最小生成树上的边都求出将这条边加入最小生成树中增大的最小代价，最后统计答案即可。（求代价时可用倍增求出链上最大值和次大值（次大值是为了保证是严格的最小生成树）） 不知道为什么sort来合并比O(1)合并快两倍…… #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;algorithm&gt; #define N 620000 using namespace std; int fa[N],Next[N],v[N],h[N],w[N],tot,f[N/6][21],dep[N/6],c[N]; int b[5],n,m; struct node{ int x,y,z; }a[N]; struct illyasviel{ int x,y; int clear(){x=0,y=0;} }g[N/6][21]; bool cmp(node x,node y){ return x.z&lt;y.z; } int find(int x){ if(fa[x]==x)return x; return fa[x]=find(fa[x]); } int add(int x,int y,int z){ tot++; Next[tot]=h[x]; v[tot]=y; w[tot]=z; h[x]=tot; } illyasviel merge(illyasviel x,illyasviel y){ illyasviel ans; ans.clear(); b[1]=x.x; b[2]=x.y; b[3]=y.x; b[4]=y.y; sort(b+1,b+1+4); ans.x=b[4]; for(int i=1;i&lt;=3;i++)if(b[i]&lt;b[4])ans.y=b[i]; return ans; } int dfs(int x,int fa){ dep[x]=dep[fa]+1; f[x][0]=fa; for(int i=1;i&lt;=20;i++)f[x][i]=f[f[x][i-1]][i-1]; for(int i=1;i&lt;=20;i++)g[x][i]=merge(g[x][i-1],g[f[x][i-1]][i-1]); for(int i=h[x];i;i=Next[i]){ if(v[i]==fa)continue; g[v[i]][0].x=w[i]; dfs(v[i],x); } } illyasviel lca(int x,int y){ illyasviel ans; ans.clear(); if(dep[x]&lt;dep[y])swap(x,y); for(int i=20;i&gt;=0;i--)if(dep[f[x][i]]&gt;=dep[y])ans=merge(g[x][i],ans),x=f[x][i]; if(x==y)return ans; for(int i=20;i&gt;=0;i--){ if(f[x][i]!=f[y][i]){ ans=merge(ans,g[x][i]); ans=merge(ans,g[y][i]); x=f[x][i];y=f[y][i]; } } ans=merge(ans,g[x][0]); ans=merge(ans,g[y][0]); return ans; } int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=m;i++){ scanf(&quot;%d%d%d&quot;,&amp;a[i].x,&amp;a[i].y,&amp;a[i].z); } long long ans=0; for(int i=1;i&lt;=n;i++)fa[i]=i; sort(a+1,a+1+m,cmp); int oo=0; for(int i=1;i&lt;=m;i++){ if(find(a[i].x)!=find(a[i].y)){ c[i]=1; ans+=0LL+a[i].z; fa[find(a[i].x)]=find(a[i ].y); add(a[i].x,a[i].y,a[i].z); add(a[i].y,a[i].x,a[i].z); oo=max(a[i].z,oo); } } dfs(1,0); long long bns=0x7fffffff; for(int i=1;i&lt;=m;i++){ if(a[i].z-oo&gt;=bns)continue; if(c[i]==0){ illyasviel p=lca(a[i].x,a[i].y); bns=min(bns,(a[i].z-p.x&gt;0)?0LL+a[i].z-p.x:0LL+a[i].z-p.y); } } printf(&quot;%lld\\n&quot;,ans+bns); } 原题链接：次小生成树 Tree","path":"2018/07/16/次小生成树-tree/"},{"title":"gcd","text":"题目大意： 对于给出的n个询问，每次求有多少个数对(x,y)(x,y)(x,y)，满足a≤x≤ba\\leq x\\leq ba≤x≤b，c≤y≤dc\\leq y\\leq dc≤y≤d，且gcd(x,y)=kgcd(x,y)=kgcd(x,y)=k，gcd(x,y)gcd(x,y)gcd(x,y)函数为x和y的最大公约数。 题解： 莫比乌斯反演 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #define N 120000 using namespace std; int p[N],prime[N],mu[N],f[N],tot; int pre(){ mu[1]=1; for(int i=2;i&lt;=N-10;i++){ if(p[i]==0)prime[++tot]=i,mu[i]=-1; for(int j=1;j&lt;=tot&amp;&amp;i*prime[j]&lt;=N-10;j++){ p[i*prime[j]]=1; mu[i*prime[j]]=-mu[i]; if(i%prime[j]==0){ mu[i*prime[j]]=0; break; } } } for(int i=1;i&lt;=N-10;i++)f[i]=f[i-1]+mu[i]; } long long cal(int n,int m){ long long ans=0; if(n*m==0)return 0; if(n&gt;m)swap(n,m); for(int i=1;i&lt;=n;i++){ int j=min(n/(n/i),m/(m/i)); ans+=1LL*(n/i)*(m/i)*(f[j]-f[i-1]); i=j; } // printf(&quot;%d %d %d\\n&quot;,n,m,ans); return ans; } int main(){ int n; pre(); scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++){ int a,b,c,d,k; scanf(&quot;%d%d%d%d%d&quot;,&amp;a,&amp;b,&amp;c,&amp;d,&amp;k); printf(&quot;%lld\\n&quot;,cal(b/k,d/k)-cal(b/k,(c-1)/k)-cal((a-1)/k,d/k)+cal((a-1)/k,(c-1)/k)); } } 原题链接：gcd","path":"2018/07/16/弱智反演/"},{"title":"JSOI2008 火星人prefix","text":"题目大意： 求一个动态字符串的某两个位置的最长公共前缀。 题解： 用splay维护hash值然后二分长度即可。 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #define P 9875321 #define N 220000 using namespace std; char s[N],c[N]; int n,m; int p[N]; struct spaly{ int ch[N][2],id[N]; int fa[N],siz[N],v[N],hs[N]; int rt,tot; int update(int x){ int l=ch[x][0],r=ch[x][1]; siz[x]=siz[l]+siz[r]+1; hs[x]=(hs[l]+1LL*v[x]*p[siz[l]]%P+1LL*p[siz[l]+1]*hs[r]%P)%P; } int rotate(int x,int &amp;k){ int y=fa[x],z=fa[y],l,r; if(ch[y][0]==x)l=0;else l=1;r=l^1; if(y==k)k=x; else {if(ch[z][0]==y)ch[z][0]=x;else ch[z][1]=x;} fa[x]=z;fa[y]=x;fa[ch[x][r]]=y; ch[y][l]=ch[x][r];ch[x][r]=y; update(y);update(x); } int splay(int x,int &amp;k){ while(x!=k){ int y=fa[x],z=fa[y]; if(y!=k){ if((ch[y][0]==x)^(ch[z][0]==y))rotate(x,k); else rotate(y,k); } rotate(x,k); } } int find(int x,int rk){ int l=ch[x][0],r=ch[x][1]; if(siz[l]+1==rk)return x; if(siz[l]+1&lt;rk)return find(r,rk-siz[l]-1); if(siz[l]+1&gt;rk)return find(l,rk); } int insert(int k,int val){ int x=find(rt,k+1),y=find(rt,k+2); splay(x,rt);splay(y,ch[x][1]); tot++;ch[y][0]=tot;fa[tot]=y;v[tot]=val; update(tot);update(y);update(x); } int query(int k,int val){ int x=find(rt,k),y=find(rt,k+val+1); splay(x,rt);splay(y,ch[x][1]); return hs[ch[y][0]]; } int solve(int x,int y){ int l=1,r=min(tot-x,tot-y)-1,ans=0; while(l&lt;=r){ int mid=(l+r)/2; if(query(x,mid)==query(y,mid)){l=mid+1;ans=mid;} else r=mid-1; } return ans; } void build(int l,int r,int f){ if(l&gt;r)return; int now=id[l],last=id[f]; if(l==r){ v[now]=hs[now]=c[l]-'a'+1; fa[now]=last;siz[now]=1; if(l&lt;f)ch[last][0]=now; else ch[last][1]=now; return; } int mid=(l+r)&gt;&gt;1;now=id[mid]; build(l,mid-1,mid);build(mid+1,r,mid); v[now]=c[mid]-'a'+1;fa[now]=last;update(now); if(mid&lt;f)ch[last][0]=now; else ch[last][1]=now; } }splay; int main(){ scanf(&quot;%s&quot;,c+2); n=strlen(c+2); p[0]=1;for(int i=1;i&lt;=150004;i++)p[i]=p[i-1]*27%P; for(int i=1;i&lt;=n+2;i++)splay.id[i]=i; splay.build(1,n+2,0);splay.tot=n+2;splay.rt=(n+3)&gt;&gt;1; scanf(&quot;%d&quot;,&amp;m); int x,y; char s[2],d[2]; for(int i=1;i&lt;=m;i++){ scanf(&quot;%s&quot;,s+1); scanf(&quot;%d&quot;,&amp;x); if(s[1]=='Q'){ scanf(&quot;%d&quot;,&amp;y); printf(&quot;%d\\n&quot;,splay.solve(x,y)); } if(s[1]=='R')scanf(&quot;%s&quot;,d+1),x=splay.find(splay.rt,x+1),splay.splay(x,splay.rt),splay.v[splay.rt]=d[1]-'a'+1,splay.update(splay.rt); if(s[1]=='I')scanf(&quot;%s&quot;,d+1),splay.insert(x,d[1]-'a'+1); } return 0; } 原题链接： JSOI2008火星人prefix","path":"2018/07/15/火星人/"},{"title":"Bracket","text":"题目大意： 现在有一个括号序列（不保证合法），你能够进行以下两个操作: 1：在任意位置加入一个左括号或者右括号 2：将序列最末的括号移到最前 现在想要知道，经过若干次操作后，得到的最短的字典序最小的括号序列是什么？ （“（”&lt;“）”） 题解： 通过旋转变换得到最小字典序的序列再在前后补足括号即可。 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #define N 1200000 #define getl(x) (-min(0,min(ms[x],msum[x-1]+sum2[x]))) using namespace std; int msum[N],ms[N],sum1[N],sum2[N]; int l,r,len,cl,cr,ans,minl,a[N]; char s[N]; int check(int l,int r,int ll,int rr){ for(int i=l;i&lt;=r;i++) if(s[i]=='('&amp;&amp;s[ll+i-l]==')')return 0;else if(s[i]==')'&amp;&amp;s[ll+i-l]=='(')return 1; return 0; } int main(){ scanf(&quot;%s&quot;,s+1); len=strlen(s+1); for(int i=1;i&lt;=len;i++) if(s[i]=='(')a[i]=1;else a[i]=-1; for(int i=1;i&lt;=len;i++){ s[i+len]=s[i]; a[i+len]=a[i]; } for(int i=1;i&lt;=len;i++){ sum1[i]=sum1[i-1]+a[i]; msum[i]=min(msum[i-1],sum1[i]); } for(int i=len;i;i--){ sum2[i]=sum2[i+1]+a[i]; ms[i]=min(ms[i+1]+a[i],a[i]); } minl=len; for(int i=1;i&lt;=len;i++)minl=min(minl,getl(i)); l=1,r=len; for(int i=1;i&lt;=len;i++)if(getl(i)==minl&amp;&amp;check(l,r,i,i+len-1))l=i,r=i+len-1; for(int i=1;i&lt;=minl;i++)printf(&quot;(&quot;); for(int i=l;i&lt;=r;i++)printf(&quot;%c&quot;,s[i]); for(int i=l;i&lt;=r;i++)if(s[i]=='(')cl++;else cr++; for(int i=cr;i&lt;cl;i++)printf(&quot;)&quot;); printf(&quot;\\n&quot;); } 原题链接：Bracket","path":"2018/07/15/括号匹配/"},{"title":"zuma","text":"题目大意： 给出一串数列v[1…n],一次可以消去其中的一段回文串（例如1 2 3 2 1），然后将这一段数字从v中移除。请问最少消多少次可以消除整个数列。 题解： 设f[l,r]为消去区间v[l,r]的最少需要的次数。 dfs即可。 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #define N 520 using namespace std; int f[N][N],a[N],n; int dfs(int l,int r){ if(f[l][r])return f[l][r]; if(l&gt;r)return 0; f[l][r]=1+dfs(l+1,r); for(int i=l+1;i&lt;=r;i++)if(a[i]==a[l]){ if(i==l+1)f[l][r]=min(f[l][r],1+dfs(i+1,r)); else f[l][r]=min(f[l][r],dfs(l+1,i-1)+dfs(i+1,r)); } return f[l][r]; } int main(){ scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]); printf(&quot;%d&quot;,dfs(1,n)); } 原题链接：zuma","path":"2018/07/15/消除回文串/"},{"title":"聪聪可可","text":"题目大意： 给出一棵树，询问树上有多少路径长度是3的倍数。 题解： 对于每个点维护从这个点到其子树模3为0,1,2的路径数然后随意统计一下答案即可。 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #define N 120000 using namespace std; int tot,Next[N],v[N],w[N],h[N],ans,n; int f[N][3],b[3]; int add(int x,int y,int z){ tot++; Next[tot]=h[x]; v[tot]=y; w[tot]=z; h[x]=tot; } int dfs(int x,int fa){ //xx f[x][0]++; for(int i=h[x];i;i=Next[i]){ if(v[i]==fa)continue; b[0]=0,b[1]=0,b[2]=0; dfs(v[i],x); b[(0+w[i])%3]=f[v[i]][0]; b[(1+w[i])%3]=f[v[i]][1]; b[(2+w[i])%3]=f[v[i]][2]; ans+=(b[0]*f[x][0])+(b[1]*f[x][2])+(b[2]*f[x][1]); f[x][0]+=b[0]; f[x][1]+=b[1]; f[x][2]+=b[2]; } } int gcd(int x,int y){ if(x%y==0)return y; return gcd(y,x%y); } int main(){ freopen(&quot;1.in&quot;,&quot;r&quot;,stdin); scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;n;i++){ int x,y,z; scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z); add(x,y,z); add(y,x,z); } dfs(1,0); int l=gcd(ans*2+n,n*n); printf(&quot;%d/%d\\n&quot;,(ans*2+n)/l,(n*n)/l); } 原题链接：聪聪可可","path":"2018/07/15/聪聪可可/"},{"title":"矩阵乘法","text":"题目大意： 有一个n×nn\\times nn×n的矩阵，有q个询问，每次询问(x1,y1)(x_1,y_1)(x​1​​,y​1​​)为左上角(x2,y2)(x_2,y_2)(x​2​​,y​2​​)为右下角的矩阵中第k小的数是多少。 题解： 考虑离线，整体二分答案，用树状数组判断是否可行，然后将询问往两边推即可。 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;algorithm&gt; #define lowbit(x) (x&amp;-x) using namespace std; struct node{ int x,y,w; }a[2000*2000]; struct arr{ int xa,xb,ya,yb,k,id; }q[620000],rx[620000],lx[620000]; int t[2000][2000],n,m,ans[620000]; int insert(int x,int y,int k){ for(int i=x;i&lt;=n;i+=lowbit(i)) for(int j=y;j&lt;=n;j+=lowbit(j))t[i][j]+=k; } int query(int x,int y){ int ans=0; for(int i=x;i;i-=lowbit(i)) for(int j=y;j;j-=lowbit(j))ans+=t[i][j]; return ans; } bool cmp(node x,node y){ return x.w&lt;y.w; } int find(int xb,int yb,int xa,int ya){ return query(xa,ya)-query(xa,yb-1)-query(xb-1,ya)+query(xb-1,yb-1); } int solve(int l,int r,int L,int R){ int mid=(l+r)/2; if(l==r){ for(int i=L;i&lt;=R;i++)ans[q[i].id]=a[l].w; return 0; } int o=0,u=0; for(int i=l;i&lt;=mid;i++)insert(a[i].x,a[i].y,1); for(int i=L;i&lt;=R;i++){ int t=find(q[i].xa,q[i].ya,q[i].xb,q[i].yb); if(t&lt;q[i].k){ q[i].k-=t; rx[++o]=q[i]; } else lx[++u]=q[i]; } for(int i=l;i&lt;=mid;i++)insert(a[i].x,a[i].y,-1); for(int i=L;i&lt;=L+u-1;i++)q[i]=lx[i-L+1]; for(int i=L+u;i&lt;=R;i++)q[i]=rx[i-L-u+1]; solve(l,mid,L,L+u-1); solve(mid+1,r,L+u,R); } int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); int x,tot=0; for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=n;j++){ scanf(&quot;%d&quot;,&amp;x); a[++tot].x=i; a[tot].y=j; a[tot].w=x; } } sort(a+1,a+1+tot,cmp); for(int i=1;i&lt;=m;i++)scanf(&quot;%d%d%d%d%d&quot;,&amp;q[i].xa,&amp;q[i].ya,&amp;q[i].xb,&amp;q[i].yb,&amp;q[i].k),q[i].id=i; solve(1,tot,1,m); for(int i=1;i&lt;=m;i++)printf(&quot;%d\\n&quot;,ans[i]); } 原题链接：矩阵乘法","path":"2018/07/15/矩阵第k大/"},{"title":"兔子与樱花","text":"题目大意： 很久很久之前，森林里住着一群兔子。有一天，兔子们突然决定要去看樱花。兔子们所在森林里的樱花树很特殊。樱花树由n个树枝分叉点组成，编号从0到n-1，这n个分叉点由n-1个树枝连接，我们可以把它看成一个有根树结构，其中0号节点是根节点。这个树的每个节点上都会有一些樱花，其中第i个节点有cic_ic​i​​朵樱花。樱花树的每一个节点都有最大的载重m，对于每一个节点i，它的儿子节点的个数和i节点上樱花个数之和不能超过m，即soni+ci≤mson_i+c_i\\leq mson​i​​+c​i​​≤m，其中sonison_ison​i​​表示i的儿子的个数，如果i为叶子节点，则soni=0son_i=0son​i​​=0。 现在兔子们觉得樱花树上节点太多，希望去掉一些节点。当一个节点被去掉之后，这个节点上的樱花和它的儿子节点都被连到删掉节点的父节点上。如果父节点也被删除，那么就会继续向上连接，直到第一个没有被删除的节点为止。 现在兔子们希望计算在不违背最大载重的情况下，最多能删除多少节点。 注意根节点不能被删除，被删除的节点不被计入载重。 题解： 对于最终删完之后的树来说，先删上层的点还是先删下层的点的顺序没有影响。而如果一个第i层的点删到i-2层的点上，则意味着第i-1层的点往上删了，那么，也就相当于先把第i层删到第i-1层再往上删到第i-2层。意味着，每个点往父亲删就可以了。对于每个节点往儿子贪心即可。 (场上随手写的一个贪心居然A掉了qwq) #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;algorithm&gt; #define N 4200000 using namespace std; int tot,Next[N],v[N],h[N],a[N],b[N]; int ans,m,n; int add(int x,int y){ tot++; Next[tot]=h[x]; v[tot]=y; h[x]=tot; } int dfs(int x,int fa){ for(int i=h[x];i;i=Next[i]){ a[x]++; dfs(v[i],x); } int tot=0; for(int i=h[x];i;i=Next[i]){ b[++tot]=a[v[i]]; } sort(b+1,b+1+tot); for(int i=1;i&lt;=tot;i++){ if(a[x]+b[i]-1&lt;=m)a[x]+=b[i]-1,ans++; } } int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1;i&lt;=n;i++){ int o; scanf(&quot;%d&quot;,&amp;o); for(int j=1;j&lt;=o;j++){ int x; scanf(&quot;%d&quot;,&amp;x); x++; add(i,x); } } dfs(1,0); printf(&quot;%d\\n&quot;,ans); } 原题链接：兔子与樱花","path":"2018/07/15/兔子与樱花/"},{"title":"rank","text":"题目大意： 大M正与其他m只怪兽一起参加一次吃人比赛。这场比赛总共有n轮，在每轮中吃的人越多，排名越靠前（任意一轮中不会出现任意两只怪兽吃人数相等）。最终的排名取决于各轮排名数值之和：排名数值之和越小，最终的排名越靠前。大M找到了你，想知道它在这次比赛中的期望排名。 题解： 设f[i,j]为除大M外经过第i轮后排名总和为j的期望人数,然后利用前缀和快速转移，时间复杂度O(n×m2)O(n\\times m^2)O(n×m​2​​)。 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #define N 1200 using namespace std; int a[N],n,m,sum; double ans,f[2][N*N]; int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]),sum+=a[i]; f[0][0]=m-1; int o=0; for(int i=1;i&lt;=n;i++){ o^=1; memset(f[o],0,sizeof(f[o])); double l=0; for(int j=1;j&lt;=sum;j++){ l+=f[o^1][j-1]; if(j&gt;m)l-=f[o^1][j-m-1]; f[o][j]+=(l-(j-a[i]&gt;=0?f[o^1][j-a[i]]:0))/(m-1); } } for(int i=1;i&lt;sum;i++)ans+=f[o][i]; printf(&quot;%.15lf&quot;,ans+1); } 原题链接：rank","path":"2018/07/14/期望排名/"},{"title":"sequence","text":"题目大意： 给定一个数字串，求划分为上升子串的（这里子串的大小为转成数字的大小）方案数。 题解： 考虑fi,jf_{i,j}f​i,j​​为当前划分段从i到k（k&gt;=j）的方案数（从后往前划分）。然后预处理O（1）判断串之间的大小即可。 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #define N 5200 #define P 1000000007 using namespace std; int f[N][N],c[N][N],n; char s[N]; int check(int x,int y){ int l=min(y-x,c[x][y]); return s[x+l]&lt;s[y+l]; } int main(){ scanf(&quot;%d&quot;,&amp;n); scanf(&quot;%s&quot;,s+1); for(int i=n;i;i--) for(int j=i+1;j&lt;=n;j++) if(s[i]==s[j])c[i][j]=c[i+1][j+1]+1; for(int i=n;i;i--) if(s[i]!='0'){ f[i][n-i+1]=1; for(int j=1;j&lt;=n-i;j++) if(check(i,i+j))f[i][j]=f[i+j][j]; else f[i][j]=f[i+j][j+1]; for(int j=n-i;j;j--)f[i][j]=(f[i][j]+f[i][j+1])%P; } printf(&quot;%d\\n&quot;,f[1][1]); } 原题链接：sequence","path":"2018/07/14/上升子串/"},{"title":"string","text":"题目大意: 给出一个长度为n的字符串s（由前p个小写字母组成），若给出由前p个小写字母组成的排列ts,并且将其首尾相连至少K次之后得到最终串ss(例如ts=abc,k=3，ts重复k次之后得到abcabcabc)使得原串s是ss的一个子序列，则我们称s是关于ts的“K-repeat”。 现在给出m个操作： 1：将字符串s的第L到R个字符全部替换为ch； 2：给出一个字符串ts，询问s是否为关于ts的“K-repeat”，输出K。 注意：读入所给出的s,ch全部都由前p个小写字母组成。 注意：读入所给出的s,ch全部都由前p个小写字母组成。 题解： 考虑答案为（n-多余次数） 多余次数为ts在s中出现了一段长度为o的，多余次数就是o-1。 那么维护s中相邻字符的点对，减掉这样的点对即可。 #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #define N 820000 using namespace std; int ls[N],rs[N],v[N][12][12],tag[N]; int n,m,p,l,r,ans; char s[N]; int clear(int k,int x){ tag[k]=x;ls[k]=rs[k]=x; for(int i=1;i&lt;=p;i++) for(int j=1;j&lt;=p;j++) v[k][i][j]=0; } int pushdown(int i){ if(!tag[i])return 0; clear(2*i,tag[i]); clear(2*i+1,tag[i]); tag[i]=0; } int pushup(int x){ for(int i=1;i&lt;=p;i++) for(int j=1;j&lt;=p;j++) v[x][i][j]=v[2*x][i][j]+v[2*x+1][i][j]; if(ls[2*x+1]!=rs[2*x])v[x][rs[2*x]][ls[2*x+1]]++; ls[x]=ls[2*x];rs[x]=rs[2*x+1]; } int build(int i,int l,int r){ if(l==r){ ls[i]=rs[i]=s[l]-'a'+1; return 0; } int mid=(l+r)/2; build(2*i,l,mid); build(2*i+1,mid+1,r); pushup(i); } int change(int i,int l,int r,int ll,int rr,int x){ if(ll&lt;=l&amp;&amp;r&lt;=rr){ clear(i,x); return 0; } int mid=(l+r)/2; pushdown(i); if(ll&lt;=mid)change(2*i,l,mid,ll,rr,x); if(rr&gt;mid)change(2*i+1,mid+1,r,ll,rr,x); pushup(i); } int main(){ freopen(&quot;1.in&quot;,&quot;r&quot;,stdin); scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;p); scanf(&quot;%s&quot;,s+1); build(1,1,n); while(m--){ int x; scanf(&quot;%d&quot;,&amp;x); if(x==1){ char ch; scanf(&quot;%d%d&quot;,&amp;l,&amp;r); scanf(&quot;%c%c&quot;,&amp;ch,&amp;ch); change(1,1,n,l,r,ch-'a'+1); }else{ scanf(&quot;%s&quot;,s+1); ans=n; for(int j=1;j&lt;=p;j++) for(int i=1;i&lt;j;i++) ans-=v[1][s[i]-'a'+1][s[j]-'a'+1]; printf(&quot;%d\\n&quot;,ans); } } } 原题链接：string","path":"2018/07/14/k重复/"},{"title":"Count on a tree","text":"题目大意： 询问树上链第k小的点值，强制在线。 题解： 树上可持久化线段树，时间复杂度O(nlogn)O(n\\log n)O(nlogn)。 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;algorithm&gt; #define N 1690000 #define M 220000 using namespace std; int n,m; int h[M],v[M],Next[M],rt[M],f[21][M],tot,dep[M]; int a[M],b[M],c[M]; struct seg{ int lx[N],rx[N],siz[N],l[N],r[N]; int insert(int i,int j,int a){ if(lx[i]==0){lx[i]=1,rx[i]=n;} if(lx[i]==rx[i]){ siz[i]=siz[j]+1; return 0; } int mid=(lx[i]+rx[i])/2; if(a&lt;=mid){ r[i]=r[j]; l[i]=++tot; lx[tot]=lx[i]; rx[tot]=mid; insert(l[i],l[j],a); }else{ l[i]=l[j]; r[i]=++tot; lx[tot]=mid+1; rx[tot]=rx[i]; insert(r[i],r[j],a); } siz[i]=siz[l[i]]+siz[r[i]]; } int query(int x,int y,int z,int fa,int k){ if(max(max(lx[x],lx[y]),max(lx[z],lx[fa]))==max(max(rx[x],rx[y]),max(rx[z],rx[fa])))return max(max(lx[x],lx[y]),max(lx[z],lx[fa])); int ls=siz[l[x]]+siz[l[y]]-siz[l[z]]-siz[l[fa]]; if(ls&gt;=k)return query(l[x],l[y],l[z],l[fa],k); else return query(r[x],r[y],r[z],r[fa],k-ls); } }s; int add(int x,int y){ tot++; Next[tot]=h[x]; v[tot]=y; h[x]=tot; } int dfs(int x,int fa){ dep[x]=dep[fa]+1; rt[x]=++tot; f[0][x]=fa; for(int i=1;i&lt;=20;i++)f[i][x]=f[i-1][f[i-1][x]]; s.insert(rt[x],rt[fa],c[x]); for(int i=h[x];i;i=Next[i]){ if(v[i]==fa)continue; dfs(v[i],x); } } int lca(int x,int y){ if(dep[x]&lt;dep[y])swap(x,y); for(int i=20;i&gt;=0;i--)if(dep[f[i][x]]&gt;=dep[y])x=f[i][x]; if(x==y)return x; for(int i=20;i&gt;=0;i--){ if(f[i][x]!=f[i][y])x=f[i][x],y=f[i][y]; } return f[0][x]; } int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1;i&lt;=n;i++)b[i]=a[i]; sort(b+1,b+1+n); for(int i=1;i&lt;=n;i++)c[i]=lower_bound(b+1,b+1+n,a[i])-b; for(int i=1;i&lt;n;i++){ int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); add(x,y); add(y,x); } tot=0; dfs(1,0); // for(int i=1;i&lt;=n;i++)printf(&quot;%d &quot;,dep[i]); int lastans=0; for(int i=1;i&lt;=m;i++){ int x,y,k; scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;k); x^=lastans; int z=lca(x,y); int ans=s.query(rt[x],rt[y],rt[z],rt[f[0][z]],k); printf(&quot;%d\\n&quot;,b[ans]); lastans=b[ans]; } }","path":"2018/07/14/树上计数/"},{"title":"病毒","text":"题目大意： 给定一堆01串，指定这些不能出现，问是否能够构造出一个无限长度的字符串满足这些都没有出现过。 题解： 直接建出trie图，判断有没有环（字符串末尾的点都不能经过） #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #define N 320000 using namespace std; char s[N]; int ch[N][2]; int tot,tag[N],fail[N],q[N],p[N],l[N],n; int insert(){ int l=strlen(s+1); int x=0; for(int i=1;i&lt;=l;i++){ if(ch[x][s[i]-'0']==0)ch[x][s[i]-'0']=++tot; x=ch[x][s[i]-'0']; } tag[x]=1; } int head,tail; int build(){ head=0,tail=0; int x=0; for(int i=0;i&lt;=1;i++)if(ch[x][i])q[++tail]=ch[x][i]; while(head&lt;tail){ int now=q[++head]; for(int i=0;i&lt;=1;i++){ if(!ch[now][i]){ch[now][i]=ch[fail[now]][i];continue;} q[++tail]=ch[now][i]; int p=fail[now]; while(p&amp;&amp;!ch[p][i])p=fail[p]; fail[ch[now][i]]=ch[p][i]; tag[ch[now][i]]|=tag[fail[ch[now][i]]]; } } } int dfs(int x){ p[x]++; l[x]++; for(int i=0;i&lt;=1;i++){ if(tag[ch[x][i]])continue; if(p[ch[x][i]])return 1; if(l[ch[x][i]])continue; if(dfs(ch[x][i]))return 1; } p[x]--; return 0; } int main(){ scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++){ scanf(&quot;%s&quot;,s+1); insert(); } build(); if(dfs(0))printf(&quot;TAK\\n&quot;); else printf(&quot;NIE\\n&quot;); }","path":"2018/07/14/病毒/"},{"title":"game with probability","text":"题目大意： Alice和Bob在玩一个游戏。有n个石子在这里，Alice和Bob轮流投掷硬币，如果正面朝上，则从n个石子中取出一个石子，否则不做任何事。取到最后一颗石子的人胜利。Alice在投掷硬币时有p的概率投掷出他想投的一面，同样，Bob有q的概率投掷出他相投的一面。 现在Alice先手投掷硬币，假设他们都想赢得游戏，问你Alice胜利的概率为多少。 题解： 考虑f[i]表示还剩下i个石子时，Alice先手，Alice必胜的概率 考虑g[i]表示还剩下i个石子时，Bob先手，Alice必胜的概率（Bob好可怜qwq） 假设每次都是的决策都是想取石子 fi=p×gi−1+(1−p)×gif_i=p\\times g_{i-1}+(1-p)\\times g_if​i​​=p×g​i−1​​+(1−p)×g​i​​ $g_i=q\\times f_{i-1}+(1-q)\\times f_i $ 联立一下得： fi=p×gi−1+(1−p)×q×fi−1p+q−p×qf_{i}=\\frac{p\\times g_{i-1}+(1-p)\\times q\\times f_{i-1}}{p+q-p\\times q}f​i​​=​p+q−p×q​​p×g​i−1​​+(1−p)×q×f​i−1​​​​ gi=q×fi−1+(1−q)×p×gi−1p+q−p×qg_{i}=\\frac{q\\times f_{i-1}+(1-q)\\times p\\times g_{i-1}}{p+q-p\\times q}g​i​​=​p+q−p×q​​q×f​i−1​​+(1−q)×p×g​i−1​​​​ 考虑每次是否想取石子，如果fi−1f_{i-1}f​i−1​​比gi−1g_{i-1}g​i−1​​大，说明取完之后Alice先手的胜率高，也就是Alice要在这里先手会比较优，那Alice就不会想取第i个。而跟Alice的更优决策点，应该是一样的，所以Bob也不会想要。反而亦之。最后输出fnf_nf​n​​也就是答案。总体复杂度是O(n)O(n)O(n)的，但是n特别大，但我们可以打表发现这玩意是收敛的（不知道为什么收敛），于是最多求到十万项就可以不管了。就变成了O(min(n,10000))O(min(n,10000))O(min(n,10000))(好像有人只扫了一百次就过了qwq)。 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #define N 120000 using namespace std; int n,t; double f[N],g[N],p,q; int solve(){ scanf(&quot;%d%lf%lf&quot;,&amp;n,&amp;p,&amp;q); n=min(n,110000); g[0]=1; for(int i=1;i&lt;=n;i++){ if(f[i-1]&gt;g[i-1])p=1.0-p,q=1.0-q; f[i]=(p*g[i-1]+(1-p)*q*f[i-1])/(p+q-p*q); g[i]=(q*f[i-1]+(1-q)*p*g[i-1])/(p+q-p*q); if(f[i-1]&gt;g[i-1])p=1.0-p,q=1.0-q; } printf(&quot;%.6lf\\n&quot;,f[n]); } int main(){ scanf(&quot;%d&quot;,&amp;t); while(t--)solve(); }","path":"2018/07/14/概率游戏/"},{"title":"JLOI2015 骗我呢","text":"题目大意： 给出n和m，求满足ai,j&lt;ai−1,j+1a_{i,j}&lt;a_{i-1,j+1}a​i,j​​&lt;a​i−1,j+1​​且ai,j&lt;ai,j+1a_{i,j}&lt;a_{i,j+1}a​i,j​​&lt;a​i,j+1​​且0≤ai,j≤m,1≤i≤n,1≤j≤m0\\leq a_{i,j}\\leq m,1\\leq i\\leq n,1\\leq j\\leq m0≤a​i,j​​≤m,1≤i≤n,1≤j≤m的方案数。 题解： 考虑每一行，ai,j&lt;ai,j+1a_{i,j}&lt;a_{i,j+1}a​i,j​​&lt;a​i,j+1​​，总共m个数，而值只有m+1个，意味着每一行只有一个位置的差会为2，其他都为1。 考虑对于每上面一行，ai,j&lt;ai−1,j+1a_{i,j}&lt;a_{i-1,j+1}a​i,j​​&lt;a​i−1,j+1​​，意味着对于第i行来说，他突变的位置最前能够比第i-1行的突变位置前一格。 得到O(nm)O(nm)O(nm)的方程，设fi,jf_{i,j}f​i,j​​表示第i行的未突变位置小于等于j的方案数。fi,j=fi−1,j+1+fi,j−1f_{i,j}=f_{i-1,j+1}+f_{i,j-1}f​i,j​​=f​i−1,j+1​​+f​i,j−1​​。j的范围为0到m。f0,0=1f_{0,0}=1f​0,0​​=1(因为小于等于相当于求前缀和，所以可以只有一个点有值)。 考虑将对于第i行，将其第二维下标向右移i行，得到方程fi,j=fi−1,j+fi,j−1f_{i,j}=f_{i-1,j}+f_{i,j-1}f​i,j​​=f​i−1,j​​+f​i,j−1​​。而j的范围是从i到i+m。那么原题就转化成了对一个n+1行n+m+1列的网格图(这里说的是格点)，有两条线不能越过（y=x+1,y=x−(m+2)y=x+1,y=x-(m+2)y=x+1,y=x−(m+2)），从（1,1）走到（n+1,n+m+1）的方案数。 答案等于=全集-先越过A线的-先越过B线的。 将多次触碰同一条线视为一次触碰，那么一条线触碰AB的方案要么是ABABABAB……，要么是BABABABA……。对于先触碰A的，我们考虑先删掉以A结尾的方案，加上以BA结尾的方案，减掉以ABA结尾的方案……，直到方案数为０，就退出（每次至少向前移动一次，最多移动Ｏ（ｎ）次）。那么就可以减掉所有第一次触碰禁忌线A的方案。同理可删除先触碰B的。 对于末尾为A的方案数计算，将终点对A线对称翻转，然后直接计算从(1,1)到对称点的方案（因为将路径沿A翻转，必定过A然后到终点。）而计算BA为末尾，就将点再沿B对称过去，计算(1,1)到对称点的方案。以此类推。 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #define N 13000000 #define P 1000000007 using namespace std; long long fac[N],ifac[N]; int n,m; long long power(long long x,int k){ long long ans=1; while(k){ if(k&amp;1)(ans*=x)%=P; (x*=x)%=P; k&gt;&gt;=1; } return ans; } int pre(){ fac[0]=1; for(int i=1;i&lt;=12000000;i++)fac[i]=fac[i-1]*i%P; ifac[12000000]=power(fac[12000000],P-2); for(int i=11999999;i&gt;=0;i--)ifac[i]=ifac[i+1]*(i+1)%P; } long long C(long long n,long long m){ return fac[n]*ifac[m]%P*ifac[n-m]%P; } long long calc(int x,int y){ if(x&lt;0||y&lt;0)return 0; return C(x+y,x); } int flipA(int &amp;x,int &amp;y){ swap(x,y); x--;y++; } int flipB(int &amp;x,int &amp;y){ swap(x,y); x+=m+2; y-=m+2; } int main(){ pre(); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); long long ans=calc(n+m+1,n); int x=n+m+1,y=n; while(x&gt;=0&amp;&amp;y&gt;=0){ flipA(x,y); ans-=calc(x,y); flipB(x,y); ans+=calc(x,y); ans%=P; } x=n+m+1,y=n; while(x&gt;=0&amp;&amp;y&gt;=0){ flipB(x,y); ans-=calc(x,y); flipA(x,y); ans+=calc(x,y); ans%=P; } ans+=P; ans%=P; printf(&quot;%lld&quot;,ans); }","path":"2018/07/08/JLOI2015-骗我呢/"},{"title":"JLOI2015 装备购买","text":"题目大意： 给n个装备，每个装备有m个属性，求花费最小的基底。 题解： 排序，贪心，然后用线性基维护即可。 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; using namespace std; #define eps 1e-8 const int N=505; int n,m; long double lb[N][N]; struct node{ long double a[N]; int w; }s[N]; int tot,ans; bool cmp(node x,node y){return x.w&lt;y.w;} int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) for(int j=1,x;j&lt;=m;j++)scanf(&quot;%llf&quot;,&amp;s[i].a[j]); for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;s[i].w); sort(s+1,s+1+n,cmp); for(int x=1;x&lt;=n;x++) for(int i=1;i&lt;=m;i++) if(fabs(s[x].a[i])&gt;=eps){ if(fabs(lb[i][i])&lt;eps){ for(int j=i;j&lt;=m;j++)lb[i][j]=s[x].a[j]; tot++; ans+=s[x].w; break; } for(int j=m;j&gt;=i;j--)s[x].a[j]-=lb[i][j]*(s[x].a[i]/lb[i][i]); } printf(&quot;%d %d\\n&quot;,tot,ans); }","path":"2018/07/08/JLOI2015-装备购买/"},{"title":"JLOI2015 城池攻占","text":"题目描述： 小铭铭最近获得了一副新的桌游，游戏中需要用m个骑士攻占n个城池。 这n个城池用1到n的整数表示。除1号城池外，城池i会受到另一座城池fif_if​i​​的管辖，其中fi&lt;if_i &lt;if​i​​&lt;i。也就是说，所有城池构成了一棵有根树。这m个骑士用1到m的整数表示，其中第i个骑士的初始战斗力为sis_is​i​​，第一个攻击的城池为cic_ic​i​​。 每个城池有一个防御值hih_ih​i​​，如果一个骑士的战斗力大于等于城池的生命值，那么骑士就可以占领这座城池；否则占领失败，骑士将在这座城池牺牲。占领一个城池以后，骑士的战斗力将发生变化，然后继续攻击管辖这座城池的城池，直到占领1号城池，或牺牲为止。 除1号城池外，每个城池i会给出两个战斗力变化参数aia_ia​i​​, viv_iv​i​​。若ai=0a_i=0a​i​​=0，攻占城池i以后骑士战斗力会增加viv_iv​i​​；若ai=1a_i =1a​i​​=1，攻占城池i以后，战斗力会乘以viv_iv​i​​。注意每个骑士是单独计算的。也就是说一个骑士攻击一座城池，不管结果如何，均不会影响其他骑士攻击这座城池的结果。 现在的问题是，对于每个城池，输出有多少个骑士在这里牺牲；对于每个骑士，输出他攻占的城池数量。 题解： 考虑对于一个点来说，初始值越大，最后能到达的高度也就越高。那么直接倍增维护跳2^i所需的初始值，并将函数复合即可。 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #define N 320000 using namespace std; long long fa[21][N],f[21][N],g[21][N],l[21][N]; long long p[N],a[N],v[N]; long long ans[N],bns[N]; int n,m; int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)scanf(&quot;%lld&quot;,&amp;p[i]); for(int i=2;i&lt;=n;i++)scanf(&quot;%lld%lld%lld&quot;,&amp;fa[0][i],&amp;a[i],&amp;v[i]); for(int i=1;i&lt;=n;i++){ f[0][i]=1;g[0][i]=0; if(a[i]==0)g[0][i]=v[i]; else f[0][i]=v[i]; l[0][i]=p[i]; for(int j=1;j&lt;=20;j++){ fa[j][i]=fa[j-1][fa[j-1][i]]; if(fa[j][i]==0)break; f[j][i]=f[j-1][fa[j-1][i]]*f[j-1][i]; g[j][i]=g[j-1][fa[j-1][i]]+f[j-1][fa[j-1][i]]*g[j-1][i]; l[j][i]=max(l[j-1][i],(l[j-1][fa[j-1][i]]-g[j-1][i])/f[j-1][i]+((l[j-1][fa[j-1][i]]-g[j-1][i])%f[j-1][i]!=0)); } } for(int i=1;i&lt;=m;i++){ long long x,y; scanf(&quot;%lld%lld&quot;,&amp;x,&amp;y); int k=i; for(int i=20;i&gt;=0;i--){ if(fa[i][y]==0)continue; if(x&gt;=l[i][y]){ bns[k]+=(1&lt;&lt;i); x=x*f[i][y]+g[i][y]; y=fa[i][y]; } } if(x&gt;=p[y])bns[i]++; else ans[y]++; } for(int i=1;i&lt;=n;i++)printf(&quot;%d\\n&quot;,ans[i]); for(int i=1;i&lt;=m;i++)printf(&quot;%d\\n&quot;,bns[i]); }","path":"2018/07/08/JLOI2015-城池攻占/"},{"title":"JLOI2015 有意义的字符串","text":"题目大意： 求[(b+d2)n][(\\frac{b+\\sqrt{d}}{2})^n][(​2​​b+√​d​​​​​)​n​​] mod 752844341257957693775284434125795769377528443412579576937。 题解： 将式子转化成([(b+d2)n]+[(b−d2)n])−[(b−d2)n]([(\\frac{b+\\sqrt{d}}{2})^n]+[(\\frac{b-\\sqrt{d}}{2})^n])-[(\\frac{b-\\sqrt{d}}{2})^n]([(​2​​b+√​d​​​​​)​n​​]+[(​2​​b−√​d​​​​​)​n​​])−[(​2​​b−√​d​​​​​)​n​​] 将左边看成特征方程的两个解，还原特征方程。 x2−bx+b2−d4=0x^2-bx+\\frac{b^2-d}{4}=0x​2​​−bx+​4​​b​2​​−d​​=0 将式子左边括号中转成一个数列a，得an=an−1b+an−2d−b24a_n=a_{n-1}b+a_{n-2}\\frac{d-b^2}{4}a​n​​=a​n−1​​b+a​n−2​​​4​​d−b​2​​​​ 这个数列可通过矩阵快速幂求得，而减号后的只会为0或者1（按照数据范围讨论），特判即可。 复杂度O(log2n)O(\\log^2n)O(log​2​​n)：因为这个模数很恶心，所以要再花一个log时间来快速乘法，使得不会爆longlong。 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #define P 7528443412579576937LL using namespace std; struct matrix{ long long a[3][3]; int clear(){memset(a,0,sizeof(a));} }E; long long add(long long x,long long y){ long long ans=-P+x+y; if(ans&lt;0)ans+=P; return ans; } long long mul(long long x,long long y){ long long ans=0; while(y){ if(y&amp;1)ans=add(ans,x); x=add(x,x); y&gt;&gt;=1; } return ans; } matrix operator * (matrix a,matrix b){ matrix ans; ans.clear(); for(int i=1;i&lt;=2;i++){ for(int j=1;j&lt;=2;j++){ for(int k=1;k&lt;=2;k++){ ans.a[i][j]=add(mul(a.a[i][k],b.a[k][j]),ans.a[i][j]); } } } return ans; } matrix power(matrix x,long long k){ matrix ans; ans.clear(); ans=E; while(k){ if(k&amp;1)ans=ans*x; x=x*x; k&gt;&gt;=1; } return ans; } int main(){ E.a[1][1]=1; E.a[2][2]=1; long long b,d,n; scanf(&quot;%lld%lld%lld&quot;,&amp;b,&amp;d,&amp;n); matrix o; o.clear(); o.a[1][1]=2; o.a[1][2]=b; matrix p; p.clear(); p.a[2][1]=1; p.a[2][2]=b; p.a[1][2]=(d-b*b)/4; o=o*power(p,n); printf(&quot;%lld&quot;,o.a[1][1]-(b*b!=d&amp;&amp;n%2==0)); }","path":"2018/07/05/JLOI2015-有意义的字符串/"},{"title":"NOI2014 购票","text":"题目大意： 有一棵树，对于每个点v有四个参数,svs_vs​v​​,pvp_vp​v​​,qvq_vq​v​​,lvl_vl​v​​。 svs_vs​v​​表示当前点到父亲节点的距离。如果d为每次跳跃的距离，那么每次跳跃的费用为dpv+qvdp_v+q_vdp​v​​+q​v​​。现在所有点都要去到1号点，并且他们每次往上跳不能超过距离lvl_vl​v​​。对于每个点求最小花费。 n≤2∗105n\\leq2*10^5n≤2∗10​5​​,其余所有运算不超过longlong。 题解： 链上做法：斜率优化 设did_id​i​​为1号点到i号点的距离 fi=min(fj+(di−dj)pi+qi)f_i=min(f_j+(d_i-d_j)p_i+q_i)f​i​​=min(f​j​​+(d​i​​−d​j​​)p​i​​+q​i​​) 设选k由于j且dk&gt;djd_k&gt;d_jd​k​​&gt;d​j​​： fk+(di−dk)pi+qi&lt;fj+(di−dj)pi+qif_k+(d_i-d_k)p_i+q_i&lt;f_j+(d_i-d_j)p_i+q_if​k​​+(d​i​​−d​k​​)p​i​​+q​i​​&lt;f​j​​+(d​i​​−d​j​​)p​i​​+q​i​​ 整理得： fk−fjdk−dj&lt;pi\\frac{f_k-f_j}{d_k-d_j}&lt;p_i​d​k​​−d​j​​​​f​k​​−f​j​​​​&lt;p​i​​ 树链剖分+凸包合并O(nlog3n)O(n\\log^3 n)O(nlog​3​​n)： 对于一条链来说，直接斜率优化即可，那么对于树上，我们可以按照dfs的顺序，一次加入点，并将树树剖，依次求出f值，在插入线段树的时候，只有左右儿子都是满时才合并，因为没加入的都不会被查询，所以可在(nlog3n)(n\\log^3n)(nlog​3​​n)的时间里求出答案（树剖一条链会有log段，限制lil_il​i​​在线段树上取区间总共有log个，每个区间二分得到答案又一个log）（因为树剖常数小所以能过qwq）（然而懒惰的我写了下面的方法。） CDQ+树分治+凸包合并O(nlog2n)O(n\\log^2n)O(nlog​2​​n)： 对于每次分治，把重心堵住，不停地堵住，然后利用当前节点到重心的链去更新重心答案，再递归计算。（看代码应该极好理解） #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;algorithm&gt; #define N 420000 #define slope(x,y) ((f[y]-f[x]+0.0)/(d[y]-d[x])) #define cal(i,j) (0LL+f[j]+(d[i]-d[j])*p[i]+q[i]) using namespace std; long long n,fa[N],tot,h[N],v[N],Next[N],siz[N],g[N],cnt,Q[N],o[N]; long long p[N],q[N],L[N],d[N],w[N],f[N]; struct node{long long w,id;}a[N]; bool cmp(node x,node y){return x.w&gt;y.w;} int add(int x,int y,long long z){ Next[++tot]=h[x]; h[x]=tot; v[tot]=y; w[tot]=z; } int dfs(int x){ siz[x]=1; for(int i=h[x];i;i=Next[i]){ d[v[i]]=d[x]+w[i]; dfs(v[i]); siz[x]+=siz[v[i]]; } } int get(int x,int S,int &amp;rt){ g[x]=0; siz[x]=1; for(int i=h[x];i;i=Next[i]){ if(o[v[i]])continue; get(v[i],S,rt); siz[x]+=siz[v[i]]; g[x]=max(g[x],siz[v[i]]); } g[x]=max(g[x],S-siz[x]); if(g[x]&lt;g[rt]&amp;&amp;siz[x]&gt;1)rt=x; } int dfs2(int x){ a[++cnt].id=x; a[cnt].w=d[x]-L[x]; for(int i=h[x];i;i=Next[i])if(!o[v[i]])dfs2(v[i]); } int solve(int x,int S){ if(x==2){ x++; x--; } if(S==1)return 0; int rt=0,now; get(x,S,rt); for(int i=h[rt];i;i=Next[i])o[v[i]]=1; solve(x,S-siz[rt]+1); cnt=0; for(int i=h[rt];i;i=Next[i])dfs2(v[i]); sort(a+1,a+cnt+1,cmp); now=rt; int top,l,r,mid,pos; top=0; for(int i=1;i&lt;=cnt;i++){ while(now!=fa[x]&amp;&amp;d[a[i].id]-L[a[i].id]&lt;=d[now]){ while(top&gt;1&amp;&amp;slope(Q[top],now)&gt;=slope(Q[top-1],Q[top]))top--; Q[++top]=now;now=fa[now]; } if(top&gt;0){ l=1;r=top;pos=1; while(l&lt;=r){ mid=(l+r)&gt;&gt;1; if(mid==top){pos=top;break;} if(slope(Q[mid],Q[mid+1])&gt;=p[a[i].id])l=mid+1,pos=mid+1; else r=mid-1; } f[a[i].id]=min(f[a[i].id],cal(a[i].id,Q[pos])); } } for(int i=h[rt];i;i=Next[i])solve(v[i],siz[v[i]]); } int main(){ long long x; scanf(&quot;%lld%lld&quot;,&amp;n,&amp;x); for(int i=2;i&lt;=n;i++){ scanf(&quot;%lld%lld%lld%lld%lld&quot;,&amp;fa[i],&amp;x,&amp;p[i],&amp;q[i],&amp;L[i]); add(fa[i],i,x); } dfs(1); g[0]=n+1; for(int i=2;i&lt;=n;i++)f[i]=1LL&lt;&lt;60; solve(1,siz[1]); for(int i=2;i&lt;=n;i++)printf(&quot;%lld\\n&quot;,f[i]); }","path":"2018/07/05/NOI2014-购票/"},{"title":"NOI2014 随机数生成器","text":"题目大意： 给出一个随机生成的矩阵（数字为1到n*m），求字典序最小的排序后的从(1,1)(1,1)(1,1)到(n,m)(n,m)(n,m)的数字序列。 题解： 按照题意模拟出来之后从小到大贪心，每次加入点之后把不可能的情况排除，直接暴力排除（遇到被排除的就退），因为每个点最多只会被排除一次，所以排除的复杂度是O(n∗m)O(n*m)O(n∗m)的，模拟出矩阵也是O(n∗m)O(n*m)O(n∗m)的，总复杂度为O(n∗m)O(n*m)O(n∗m)。 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #define swap(x,y) t=x;x=y;y=t; using namespace std; int x0,a,b,c,d,n,m,q,tot; int f[26000000],p[26000000],l[10200],r[10200]; static int t; int main(){ scanf(&quot;%d%d%d%d%d&quot;,&amp;x0,&amp;a,&amp;b,&amp;c,&amp;d); scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;q); for(int i=1;i&lt;=n*m;i++)f[i]=i; for(int i=1;i&lt;=n*m;i++){ x0=(1LL*a*x0*x0+1LL*b*x0+c)%d; swap(f[i],f[x0%i+1]); } static int x,y; for(static int i=1;i&lt;=q;i++){ scanf(&quot;%d%d&quot;,&amp;x,&amp;y); swap(f[x],f[y]); } for(static int i=1;i&lt;=n*m;i++)p[f[i]]=i; for(static int i=1;i&lt;=n*m;i++){ bool ooo=true; int y=(p[i]-1)%m+1; int x=(p[i]-y)/m+1; if(p[i]==0)continue; for(int i=x-1;i&gt;=1;i--){ for(int j=y+1;j&lt;=m;j++){ int ooo=((i-1)*m+j); if(p[f[ooo]]==0)break; p[f[ooo]]=0; } } for(int i=x+1;i&lt;=n;i++){ for(int j=y-1;j&gt;=1;j--){ int ooo=((i-1)*m+j); if(p[f[ooo]]==0)break; p[f[ooo]]=0; } } if(ooo==false)continue; l[++tot]=x; r[tot]=y; printf(&quot;%d &quot;,i); if(tot==n+m-1)return 0; } }","path":"2018/07/02/NOI2014-随机数生成器/"},{"title":"NOI2014 魔法森林","text":"题目大意： 一个无向图，每条边两个值a和b，求1到n路径上的min(max(ai)+max(bj))min(max(a_i)+max(b_j))min(max(a​i​​)+max(b​j​​))。 题解： 按照a为第一关键字，b为第二关键字排序，按顺序加边，再松弛，因为每条边松弛一次，所以跟整张图的SPFA是一个复杂度。相当于对于每个a的可能值都做一次b的最短路，约等于优化暴力（spaly维护最小生成树的做法我不会啊qwq） #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;algorithm&gt; #define N 12000000 using namespace std; struct node{ int x,y,a,b; }a[N]; int tot,Next[N],v[N],w[N],h[N],d[N]; int q[N],p[N],n,m; int add(int x,int y,int z){ tot++; Next[tot]=h[x]; v[tot]=y; w[tot]=z; h[x]=tot; } bool cmp(node x,node y){ if(x.a==y.a)return x.b&lt;y.b; return x.a&lt;y.a; } int spfa(int x){ q[1]=x; if(x==1){ x++; x--; } int head=0,tail=1; p[x]=1; while(head&lt;tail){ int now=q[++head]; if(d[now]==0)continue; for(int i=h[now];i;i=Next[i]){ if(max(d[now],w[i])&lt;d[v[i]]||d[v[i]]==0){ d[v[i]]=max(d[now],w[i]); if(p[v[i]]==0){ p[v[i]]=1; q[++tail]=v[i]; } } } p[now]=0; } p[x]=0; } int main(){ d[1]=1; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=m;i++)scanf(&quot;%d%d%d%d&quot;,&amp;a[i].x,&amp;a[i].y,&amp;a[i].a,&amp;a[i].b); sort(a+1,a+1+m,cmp); int ans=1000000000,bns=1000000000; for(int i=1;i&lt;=m;i++){ add(a[i].x,a[i].y,a[i].b); add(a[i].y,a[i].x,a[i].b); spfa(a[i].x); spfa(a[i].y); if(d[n]==0)continue; bns=a[i].a+d[n]; if(bns&lt;ans)ans=bns; } spfa(1); if(ans==1000000000)ans=-1; printf(&quot;%d&quot;,ans); }","path":"2018/07/02/NOI2014-魔法森林/"},{"title":"NOI2014 动物园","text":"题目大意： 对于S的每个前缀T，对于T求出有多少个长度小于|T|的前缀和后缀相同，讲每个前缀T的答案加一乘起来膜100000000710000000071000000007。 题解： 直接求Next数组然后倍增就好了。（倍增前后坐标相反能快差不多一倍，不然卡不过去qwq） #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #define N 1200000 #define P 1000000007 using namespace std; char s[N]; long long f[21][N],ans; int Next[N],q[N],g[N]; int cal(int x){ if(f[0][x]==0)return 0; int o=x; for(int i=20;i&gt;=0;i--) if(f[i][o]&gt;x/2)o=f[i][o]; return f[0][o]; } int get(){ memset(f,0,sizeof(f)); memset(q,0,sizeof(q)); memset(g,0,sizeof(g)); memset(Next,0,sizeof(Next)); int l=strlen(s+1); q[1]=1; for(int i=2;i&lt;=l;i++){ int j=Next[i-1]; while(j&amp;&amp;s[j+1]!=s[i])j=Next[j]; Next[i]=j+(s[j+1]==s[i]); q[i]=q[Next[i]]+1; f[0][i]=Next[i]; for(int j=1;j&lt;=20;j++){ f[j][i]=f[j-1][f[j-1][i]]; if(f[j][i]==0)break; } } ans=1; for(int i=1;i&lt;=l;i++)g[i]=q[cal(i)]; for(int i=1;i&lt;=l;i++)(ans*=1LL*g[i]+1)%=P; printf(&quot;%lld\\n&quot;,ans); } int main(){ int n; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++){ scanf(&quot;%s&quot;,s+1); get(); } }","path":"2018/07/02/NOI2014-动物园/"},{"title":"NOI2014 起床困难综合征","text":"题目大意： 给定一系列位运算操作，在1到m里选一个数，使这个数在经历一系列操作后值最大。 题解： 对于每一位分别求出输入时是0和1为多少，从高位往低位贪心选择较大值，如果在相同满足要求的结果下选择输入较小的。 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; using namespace std; long long n,m,d,ans,l; char s[100]; int main(){ scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m); long long x=0,y=(1LL&lt;&lt;32)-1; for(int i=1;i&lt;=n;i++){ scanf(&quot;%s&quot;,s+1); scanf(&quot;%lld&quot;,&amp;d); if(s[1]=='O')x=x|d,y=y|d; if(s[1]=='A')x=x&amp;d,y=y&amp;d; if(s[1]=='X')x=x^d,y=y^d; } for(int i=32;i&gt;=0;i--){ if(x&amp;(1LL&lt;&lt;(i))){ ans+=1LL&lt;&lt;i; }else{ if(y&amp;(1LL&lt;&lt;i)){ if(l+(1LL&lt;&lt;i)&lt;=m){ ans+=1LL&lt;&lt;i; l+=1LL&lt;&lt;i; } } } } printf(&quot;%lld&quot;,ans); }","path":"2018/07/02/NOI2014-起床困难综合征/"},{"title":"NOI2007 生成树计数","text":"题目大意： 有一条链，链上长度不超过k的点之间都会进行连边，求生成树个数。 题解： 60%做法：O(n3)O(n^3)O(n​3​​),n≤100n \\leq 100n≤100 那么直接连边按照，用矩阵树定理高斯消元解行列式即可。 因为n≤100n\\leq100n≤100那么直接连边按照，用矩阵树定理n3n^3n​3​​高斯消元解行列式即可。 100%做法：O(l3log(n))O(l^3log(n))O(l​3​​log(n)),n≤1015n\\leq 10^{15}n≤10​15​​,l为所有联通形式种类，当k=5时l=52。 考虑到对于第i-k号点，如果最后会成为生成树，他必定与i-k+1到i号点中至少一个是一个联通快的。因此，我们维护fi,jf_{i,j}f​i,j​​表示，在当前第i个点，前j个点的联通块是怎么样的，每次转移则是用第i号点与前面的连边情况进行转移，维护判断i-k号点在转移后是否与i-k+1到i号点中的部分点联通。搜索我们可以得到转移矩阵。 初始条件：因为在前k个点中，所有点之间都是两两相连的，n个点的完全图的最小生成树是nn−2n^{n-2}n​n−2​​，这个可用purfer序列简易证明。 关于最小表示法：既联通情况2,2,3,1与联通情况1,1,2,3是相同的，所有本质相同的情况我们用它的最小表示来识别它。 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;map&gt; #define N 120 #define P 65521 using namespace std; int cnt,k,tot,l; int a[10],b[10],q[60]; long long n; map&lt;int,int&gt;p; struct matrix{ long long a[N][N]; int clear(){memset(a,0,sizeof(a));} int E(){for(int i=1;i&lt;=cnt;i++)a[i][i]=1;} }g,f; matrix operator *(matrix a,matrix b){ matrix ans; ans.clear(); for(int i=1;i&lt;=cnt;i++){ for(int j=1;j&lt;=cnt;j++){ for(int k=1;k&lt;=cnt;k++){ (ans.a[i][j]+=a.a[i][k]*b.a[k][j])%=P; } } } return ans; } matrix power(matrix x,long long k){ matrix ans; ans.clear(); ans.E(); while(k){ if(k&amp;1)ans=ans*x; x=x*x; k&gt;&gt;=1; } return ans; } int get(int x){ memset(a,0,sizeof(a)); memset(b,0,sizeof(b)); int tot=0; for(int i=1;i&lt;=k;i++)a[i]=(x&gt;&gt;(3*(k-i)))%(1&lt;&lt;3); for(int i=1;i&lt;=k;i++){ if(b[a[i]])a[i]=b[a[i]]; else b[a[i]]=++tot,a[i]=tot; } int y=0; for(int i=1;i&lt;=k;i++)y=y&lt;&lt;3,y+=a[i]; return y; } int powerr(int x,int k){ int ans=1; if(k&lt;=0)return ans; while(k){ if(k&amp;1)(ans*=x)%=P; (x*=x)%=P; k&gt;&gt;=1; } return ans; } int gett(int x){ int ans=1; memset(a,0,sizeof(a)); memset(b,0,sizeof(b)); for(int i=1;i&lt;=k;i++)a[i]=(x&gt;&gt;(3*(k-i)))%(1&lt;&lt;3),b[a[i]]++; for(int i=1;i&lt;=k;i++)ans*=powerr(b[i],b[i]-2); return ans; } int dfs(int x,int o){ if(x==l){ int y=get(o); if(p[y]==0){ p[y]=++cnt; q[cnt]=y; f.a[1][cnt]=gett(y); } return 0; } for(int i=1;i&lt;=k;i++){ dfs(x+1,(o&lt;&lt;3)+i); } } int check(int x,int y){ int o=0; memset(a,0,sizeof(a)); memset(b,0,sizeof(b)); for(int i=1;i&lt;=k;i++)a[i]=(x&gt;&gt;(3*(k-i)))%(1&lt;&lt;3); for(int i=2;i&lt;=k;i++){ if(a[i]==a[1])break; if(y&amp;1)continue; if(i==k)return 0; } for(int i=0;i&lt;k;i++){ if((1&lt;&lt;i)&amp;y){ if(o==0)o=a[i+1]; if(b[a[i+1]]&gt;0)return 0; b[a[i+1]]=o; } } for(int i=1;i&lt;=k;i++)if(b[a[i]]&gt;0)a[i]=o; int l=0; for(int i=2;i&lt;=k;i++)l=(l&lt;&lt;3)+a[i]; l&lt;&lt;=3; if(y!=0)l+=o; else l+=k+1; int ans=get(l); return p[ans]; } int cal(int x){ for(int i=1;i&lt;=cnt;i++){ int l=check(q[i],x); if(l&gt;0){ g.a[i][l]++; } } } int main(){ scanf(&quot;%d%lld&quot;,&amp;k,&amp;n); if(k&gt;n){ printf(&quot;%d&quot;,powerr(n,n-2)); return 0; } l=k; dfs(0,0); for(int i=0;i&lt;(1&lt;&lt;k);i++)cal(i); f=f*power(g,n-k); printf(&quot;%d\\n&quot;,f.a[1][1]); }","path":"2018/06/30/NOI2007-生成树计数/"},{"title":"NOI2007 项链工厂","text":"题目大意： 维护一个环，和一个指针，有以下几种操作（该指针的下标为1，其余为位置的下标顺时针递增）: 1:将指针逆时针移动k位 2:将环以指针做对称轴翻转 3:交换l位置和r位置上的颜色 4:将l到r染成c颜色 5:查询当前项链有多少段颜色（首尾相同算一段） 6: 查询l到r有多少段颜色 题解： 线段树 对于翻转操作，我们修改对应下标，然后更新即可，需要完成的模块有区间更新（lazy标记），区间查询，单点更新，单点查询。 （由于代码是在拍宣传片时候写的，思维极度混乱，由于实现问题甚至需要开八倍空间，这份代码极度丑陋qwq）。 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #define N 2200000 using namespace std; int a[N],n,c,ooo; struct node{ int lx[N],rx[N],tag[N],t[N],ll,rr,ans; int pushdown(int i){ if(tag[i]){ lx[i]=tag[i]; rx[i]=tag[i]; t[i]=1; tag[i*2]=tag[i]; tag[i*2+1]=tag[i]; tag[i]=0; return 0; } } int merge(int i,int l,int r){ if(tag[l])pushdown(l); if(tag[r])pushdown(r); t[i]=t[l]+t[r]-(rx[l]==lx[r]); lx[i]=lx[l]; rx[i]=rx[r]; } int build(int i,int l,int r){ if(l==r){ lx[i]=a[l]; rx[i]=a[l]; t[i]=1; return 0; } int mid=(l+r)/2; build(i*2,l,mid); build(i*2+1,mid+1,r); merge(i,i*2,i*2+1); } int insert(int i,int l,int r,int x,int y,int c){ pushdown(i); if(x&lt;=l&amp;&amp;r&lt;=y){ tag[i]=c; pushdown(i); merge(i,i*2,i*2+1); return 0; } int mid=(l+r)/2; if(mid&gt;=x)insert(i*2,l,mid,x,y,c); if(mid&lt;y)insert(i*2+1,mid+1,r,x,y,c); merge(i,i*2,i*2+1); } int add(int i){ if(ll==0&amp;&amp;rr==0){ ll=lx[i],rr=rx[i]; ans=t[i]; return 0; } ans=t[i]+ans-(rr==lx[i]); rr=rx[i]; return 0; } int query(int i,int l,int r,int x,int y){ pushdown(i); if(x&lt;=l&amp;&amp;y&gt;=r){ add(i);return ans; } int mid=(l+r)/2; if(x&lt;=mid)query(i*2,l,mid,x,y); if(y&gt;mid)query(i*2+1,mid+1,r,x,y); merge(i,i*2,i*2+1); return ans; } int clear(){ ll=0,rr=0; ans=0; return 0; } int insert(int i,int l,int r,int x,int a){ pushdown(i); if(l==r){ t[i]=1; lx[i]=a; rx[i]=a; return 0; } int mid=(l+r)/2; if(x&lt;=mid)insert(i*2,l,mid,x,a); else insert(i*2+1,mid+1,r,x,a); merge(i,i*2,i*2+1); } int query_color(int i,int l,int r,int x){ pushdown(i); if(l==r)return lx[i]; int mid=(l+r)/2; if(x&lt;=mid)return query_color(i*2,l,mid,x); else return query_color(i*2+1,mid+1,r,x); merge(i,i*2,i*2+1); } }s; int q; char ss[10]; int get(int &amp;x){ x%=n;x+=n;x%=n; if(x==0)x=n; } int tot; int main(){ int p=0; scanf(&quot;%d%d&quot;,&amp;n,&amp;c); for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]); s.build(1,1,n); scanf(&quot;%d&quot;,&amp;q); int o=1; for(int i=1;i&lt;=q;i++){ scanf(&quot;%s&quot;,ss+1); if(ss[1]=='R'){ int k; scanf(&quot;%d&quot;,&amp;k); if(p==0)o-=k; else o+=k; get(o); } if(ss[1]=='F'){p^=1;} if(ss[1]=='S'){ int l,r; scanf(&quot;%d%d&quot;,&amp;l,&amp;r); if(p==0)l+=o-1,r+=o-1; else{ l=o+1-l,r=o+1-r; } get(l),get(r); int lx=s.query_color(1,1,n,l),rx=s.query_color(1,1,n,r); s.insert(1,1,n,r,lx); s.insert(1,1,n,l,rx); } if(ss[1]=='P'){ int l,r,x; scanf(&quot;%d%d%d&quot;,&amp;l,&amp;r,&amp;x); if(p==0)l+=o-1,r+=o-1; else{ l=o+1-l,r=o+1-r; swap(l,r); } get(l),get(r); if(l&lt;=r)s.insert(1,1,n,l,r,x); else s.insert(1,1,n,1,r,x),s.insert(1,1,n,l,n,x); } if(ss[1]=='C'){ tot++; // if(tot==11){ // printf(&quot;\\n&quot;); // for(int i=1;i&lt;=n;i++)printf(&quot;%d &quot;,s.query_color(1,1,n,i)); // printf(&quot;\\n&quot;); // } int l=1,r=n,ooo=1; if(ss[2]=='S'){ scanf(&quot;%d%d&quot;,&amp;l,&amp;r); if(p==0)l+=o-1,r+=o-1; else{ l=o+1-l,r=o+1-r; swap(l,r); } get(l);get(r); } int ans=0; s.clear(); if(l&lt;=r)ans=s.query(1,1,n,l,r)-(r-l+1==n?(s.query_color(1,1,n,1)==s.query_color(1,1,n,n)):0); else{ ans=s.query(1,1,n,1,r);s.clear(); ans+=s.query(1,1,n,l,n)-(s.query_color(1,1,n,1)==s.query_color(1,1,n,n)); } printf(&quot;%d\\n&quot;,max(ans,1)); } } }","path":"2018/06/28/NOI2007-项链工厂/"},{"title":"NOI2007 货币兑换","text":"题目大意： 股市有n天，有A和B两只股票，给出aia_ia​i​​，bib_ib​i​​表示A劵和B劵的价值，rir_ir​i​​表示每天提供的A劵与B劵的比例（必须按照这个比例来买）。 给出开局的金额S，求n天后最多能得到的钱。 题解： 易证每天必须全部卖出或者全部买入 60%做法，O(n2)dpO(n^2)dpO(n​2​​)dp： fi=max(fi−1,Aj∗ai+Bj∗bi)f_i=\\max(f_{i-1},A_j*a_i+B_j*b_i)f​i​​=max(f​i−1​​,A​j​​∗a​i​​+B​j​​∗b​i​​) 100%做法，O(nlog2n)O(nlog^2n)O(nlog​2​​n)斜率优化+cdq分治: 若k优于j且AkA_kA​k​​&gt;AjA_jA​j​​，则： Aj∗ai+Bj∗bi&lt;Ak∗ai+Bk∗biA_j*a_i+B_j*b_i&lt;A_k*a_i+B_k*b_iA​j​​∗a​i​​+B​j​​∗b​i​​&lt;A​k​​∗a​i​​+B​k​​∗b​i​​ bi∗(Bj−Bk)&lt;ai∗(Ak−Aj)b_i*(B_j-B_k)&lt;a_i*(A_k-A_j)b​i​​∗(B​j​​−B​k​​)&lt;a​i​​∗(A​k​​−A​j​​) −Ak−AjBk−Bj&lt;aibi-\\frac{A_k-A_j}{B_k-B_j}&lt;\\frac{a_i}{b_i}−​B​k​​−B​j​​​​A​k​​−A​j​​​​&lt;​b​i​​​​a​i​​​​ Ak−AjBk−Bj&gt;−aibi\\frac{A_k-A_j}{B_k-B_j}&gt;-\\frac{a_i}{b_i}​B​k​​−B​j​​​​A​k​​−A​j​​​​&gt;−​b​i​​​​a​i​​​​ 考虑将BiB_iB​i​​作为横坐标AiA_iA​i​​作为纵坐标，对于每个i来说，取最优答案即在上凸包做斜率为−aibi-\\frac{a_i}{b_i}−​b​i​​​​a​i​​​​切线处取点。 CDQ分治：solve(l,r) 先按斜率−aibi-\\frac{a_i}{b_i}−​b​i​​​​a​i​​​​排序。在solve(l,r)把时间小于等于mid的放到数组前半段，大于mid的放到数组后半段，solve(l,mid)，并将其暴力构建凸包，对mid+1到r的答案进行更新（这时满足斜率单调的条件，而最先开始的按照斜率排序保证了后半段的查询中斜率式单调递增的）。然后solve(mid+1,r)，最后将l到r中的点按照横纵坐标排序（为了返回之后能构建凸包）。 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #define eps 1e-9 #define N 1200000 using namespace std; struct node{ double a,b,k,x,y,r; int id; }a[N],t[N]; int s[N]; double f[N]; int n; bool cmp(node x,node y){ return x.k&gt;y.k; } bool cmp1(node x,node y){ if(fabs(x.x-y.x)&lt;eps)return x.y&lt;y.y; return x.x&lt;y.x; } bool slope(node x,node y,node z){ return (z.x-x.x)*(y.y-x.y)-eps&lt;(y.x-x.x)*(z.y-x.y); } double slope(node x,node y){ if(fabs(x.x-y.x)&lt;eps)return 1e10; return (y.y-x.y)/(y.x-x.x); } int solve(int l,int r){ if(l==r){ f[l]=max(f[l],f[l-1]); a[l].y=f[l]/(a[l].a*a[l].r+a[l].b); a[l].x=a[l].y*a[l].r; return 0; } int mid=(l+r)/2; int l1=l-1,l2=mid; for(int i=l;i&lt;=r;i++)if(a[i].id&lt;=mid)t[++l1]=a[i];else t[++l2]=a[i]; for(int i=l;i&lt;=r;i++)a[i]=t[i]; solve(l,mid); int top=0; for(int i=l;i&lt;=mid;i++){ while(top&gt;1&amp;&amp;slope(a[s[top-1]],a[s[top]],a[i]))top--; s[++top]=i; } int j=1; for(int i=mid+1;i&lt;=r;i++){ while(j&lt;top&amp;&amp;slope(a[s[j]],a[s[j+1]])+eps&gt;a[i].k)j++; int now=a[i].id,o=s[j]; f[now]=max(f[now],a[i].a*a[o].x+a[i].b*a[o].y); } solve(mid+1,r); l1=l,l2=mid+1; for(int i=l;i&lt;=r;i++)if((l2&gt;r)||(l1&lt;=mid&amp;&amp;cmp1(a[l1],a[l2])))t[i]=a[l1++];else t[i]=a[l2++]; for(int i=l;i&lt;=r;i++)a[i]=t[i]; } int main(){ scanf(&quot;%d%lf&quot;,&amp;n,&amp;f[0]); for(int i=1;i&lt;=n;i++){ scanf(&quot;%lf%lf%lf&quot;,&amp;a[i].a,&amp;a[i].b,&amp;a[i].r); a[i].k=-a[i].a/a[i].b; a[i].id=i; } sort(a+1,a+1+n,cmp); solve(1,n); printf(&quot;%.5lf\\n&quot;,f[n]); }","path":"2018/06/28/NOI2007-货币兑换/"},{"title":"NOI2007 社交网络","text":"题目大意： 一个无向连通图，Cs,tC_{s,t}C​s,t​​表示从s到t的最短路条数，Cs,t(v)C_{s,t}(v)C​s,t​​(v)表示经过v从s到t的最短路条数。 对于每个点v，求出l(v)=∑s≠v,t≠vCs,t(v)Cs,tl(v)=\\sum \\limits_{s\\neq v,t \\neq v}\\frac{C_{s,t}(v)}{C_{s,t}}l(v)=​s≠v,t≠v​∑​​​C​s,t​​​​C​s,t​​(v)​​(s到t的最短路上经过v) 题解： 由于点数小于100，直接对于每个点SPFA完了之后暴力计算 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #define N 220000 using namespace std; int tot,h[N],Next[N],w[N],v[N]; long long n,m,p[120],q[N],d[120][120],f[120][120],behind[N]; int add(int x,int y,int z){ tot++; Next[tot]=h[x]; v[tot]=y; w[tot]=z; h[x]=tot; } int l[120]; int spfa(long long d[],long long f[],int s){ for(int i=0;i&lt;=n;i++)d[i]=0x7fffffff; int head=0,tail=1; d[s]=0; p[s]=1; q[1]=s; p[s]=1; memset(p,0,sizeof(p)); while(head&lt;tail){ int now=q[++head]; for(int i=h[now];i;i=Next[i]){ if(d[now]+w[i]&lt;d[v[i]]){ d[v[i]]=d[now]+w[i]; if(p[v[i]]==0){ q[++tail]=v[i]; p[v[i]]=1; } } } p[now]=0; } memset(l,0,sizeof(l)); for(int i=1;i&lt;=2*m;i++)if(d[v[behind[i]]]+w[i]==d[v[i]])l[v[i]]++; f[s]=1; q[1]=s; p[s]=1; head=0,tail=1; memset(p,0,sizeof(p)); while(head&lt;tail){ int now=q[++head]; for(int i=h[now];i;i=Next[i]){ if(d[v[i]]==d[now]+w[i]){ f[v[i]]+=f[now]; l[v[i]]--; if(l[v[i]]==0)q[++tail]=v[i]; } } } } double cal(int x){ double ans=0; for(int i=1;i&lt;=n;i++){ if(x==i)continue; for(int j=1;j&lt;=n;j++){ if(x==j)continue; if(d[x][i]+d[x][j]&gt;d[i][j])continue; ans+=((double)f[x][i]+0.0)*f[x][j]/f[i][j]; } } return ans; } int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=m;i++){ int x,y,z; scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z); add(x,y,z);behind[tot]=tot+1; add(y,x,z);behind[tot]=tot-1; } for(int i=1;i&lt;=n;i++)spfa(d[i],f[i],i); for(int i=1;i&lt;=n;i++)printf(&quot;%.7lf\\n&quot;,cal(i)); }","path":"2018/06/27/NOI2007-社交网络/"},{"title":"BZOJ2042 陶陶的难题II","text":"题目大意： 树上每个节点有x,y,q,p四个值，每次查询一条链上两个节点iii和jjj使得yi+qjxi+pj\\frac{y_i+q_j}{x_i+p_j}​x​i​​+p​j​​​​y​i​​+q​j​​​​最大，输出这个最大值。 题解： 二分答案kkk,判定yi+qjxi+pj&gt;k\\frac{y_i+q_j}{x_i+p_j}&gt;k​x​i​​+p​j​​​​y​i​​+q​j​​​​&gt;k yi+qj−k(xi+pj)&gt;0y_i+q_j-k(x_i+p_j)&gt;0y​i​​+q​j​​−k(x​i​​+p​j​​)&gt;0 yi−kxi+qj−kpj&gt;0y_i-kx_i+q_j-kp_j&gt;0y​i​​−kx​i​​+q​j​​−kp​j​​&gt;0 既寻找yi−kxiy_i-kx_iy​i​​−kx​i​​和qj−kpjq_j-kp_jq​j​​−kp​j​​的最大值 两组的查询方法一样，将xix_ix​i​​设为横坐标，yiy_iy​i​​设为纵坐标，维护一条链上的凸包，做一条斜率为k的直线，然后三分取得最大值，链上的凸包维护用树链剖分实现，每个线段树的节点都用vector来储存凸包。 时间复杂度：O(nlog4n)O(n\\log^4n)O(nlog​4​​n) 二分答案一个logloglog，树链剖分两个logloglog，在凸包上三分一个logloglog（如果有n2n^2n​2​​的做法可能能直接碾过去）。 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;vector&gt; #include&lt;cmath&gt; #define N 220000 #define eps (double)1e-10 using namespace std; int Next[N],v[N],h[N],siz[N],top[N],son[N],st[N],dep[N],f[N],ed[N],tot,cnt,n,m; struct illyasviel{ double x,y; }; double slope(illyasviel x,illyasviel y,illyasviel z){ return (y.y-x.y)*(z.x-x.x)&lt;(z.y-x.y)*(y.x-x.x); } struct node{ vector&lt;illyasviel&gt;a; int insert(illyasviel x){a.push_back(x);} int add(illyasviel x){ // if(fabs(x.x-a[]) if(a.size()==0){ a.push_back(x); return 0; } if(x.y&lt;=a[a.size()-1].y+eps)return 0; int o=a.size()-1; while(o&gt;=1&amp;&amp;slope(a[o-1],a[o],x)) a.pop_back(),o--; a.push_back(x); } double get(int x,double d){ return a[x].y-a[x].x*d; } double query(double d){ int l=0,r=a.size()-1; double ans=-100000000; // for(int i=0;i&lt;r;i++)printf(&quot;%.3lf %.3lf\\n&quot;,a[i].x,a[i].y); while(r-l&gt;3){ int ml=(l+r+l)/3,mr=(l+r+r)/3; if(get(ml,d)&lt;get(mr,d))l=ml; else r=mr; } for(int i=l;i&lt;=r;i++) ans=max(ans,get(i,d)); return ans; } }; node merge(node &amp;x,node &amp;y){ node ans; ans.a.clear(); int i=0,j=0; while(i&lt;x.a.size()||j&lt;y.a.size()){ if(i&lt;x.a.size()&amp;&amp;j&lt;y.a.size()){ if(x.a[i].x&lt;y.a[j].x){ ans.add(x.a[i]); i++; } else{ ans.add(y.a[j]); j++; } continue; } if(i&lt;x.a.size())ans.add(x.a[i]),i++; if(j&lt;y.a.size())ans.add(y.a[j]),j++; } return ans; } struct seg{ node a[N*4]; illyasviel s[N*4]; int build(int i,int l,int r){ if(l==r){ a[i].insert(s[ed[l]]); return 0; } int mid=(l+r)/2; build(i*2,l,mid); build(i*2+1,mid+1,r); a[i]=merge(a[i*2],a[i*2+1]); } double query(int i,int l,int r,int x,int y,double d){ if(x&lt;=l&amp;&amp;r&lt;=y)return a[i].query(d); int mid=(l+r)/2; double ans=-1000000000000.0; if(mid&gt;=x)ans=max(ans,query(i*2,l,mid,x,y,d)); if(mid&lt;y)ans=max(ans,query(i*2+1,mid+1,r,x,y,d)); return ans; } }s1,s2; int add(int x,int y){ tot++; Next[tot]=h[x]; v[tot]=y; h[x]=tot; } int dfs(int x,int fa){ siz[x]++; f[x]=fa; dep[x]=dep[fa]+1; for(int i=h[x];i;i=Next[i]){ if(v[i]==fa)continue; dfs(v[i],x); siz[x]+=siz[v[i]]; if(siz[v[i]]&gt;siz[son[x]])son[x]=v[i]; } } int dfs1(int x,int fa){ st[x]=++cnt; if(son[x])top[son[x]]=top[x]; if(son[x])dfs1(son[x],x); for(int i=h[x];i;i=Next[i]){ if(v[i]==fa||v[i]==son[x])continue; top[v[i]]=v[i]; dfs1(v[i],x); } } int lca(int x,int y){ while(top[x]!=top[y]){ if(dep[top[x]]&lt;dep[top[y]])y=f[top[y]]; else x=f[top[x]]; } return dep[x]&lt;dep[y]?x:y; } illyasviel query_illyasviel(int x,int y,double d){ illyasviel ans; ans.x=-100000000000000.0; ans.y=-100000000000000.0; if(dep[x]&lt;dep[y])swap(x,y); int r=st[x]; while(dep[top[x]]&gt;dep[y]){ ans.x=max(ans.x,s1.query(1,1,n,st[top[x]],st[x],d)); ans.y=max(ans.y,s2.query(1,1,n,st[top[x]],st[x],d)); // printf(&quot;%d %d\\n&quot;,st[top[x]],st[x]); x=f[top[x]]; } ans.x=max(ans.x,s1.query(1,1,n,st[y],st[x],d)); ans.y=max(ans.y,s2.query(1,1,n,st[y],st[x],d)); //printf(&quot;%d %d\\n&quot;,st[y],st[x]); return ans; } double check(double d,int x,int y){ int z=lca(x,y); illyasviel a,b; a=query_illyasviel(x,z,d); b=query_illyasviel(y,z,d); return max(a.x,b.x)+max(a.y,b.y); } double query(int x,int y){ double l=0.0,r=2000000.0; // printf(&quot;%.5lf\\n&quot;,check((double)4.85,x,y)); while(r-l&gt;1e-5){ double mid=(l+r)/2; if(check(mid,x,y)&gt;eps)l=mid; else r=mid; } return l+1e-6; } int main(){ scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++)scanf(&quot;%lf&quot;,&amp;s1.s[i].x); for(int i=1;i&lt;=n;i++)scanf(&quot;%lf&quot;,&amp;s1.s[i].y); for(int i=1;i&lt;=n;i++)scanf(&quot;%lf&quot;,&amp;s2.s[i].x); for(int i=1;i&lt;=n;i++)scanf(&quot;%lf&quot;,&amp;s2.s[i].y); for(int i=1;i&lt;n;i++){ int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); add(x,y); add(y,x); } dfs(1,0); top[1]=1; dfs1(1,0); for(int i=1;i&lt;=n;i++)ed[st[i]]=i; s1.build(1,1,n); s2.build(1,1,n); scanf(&quot;%d&quot;,&amp;m); for(int i=1;i&lt;=m;i++){ int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); printf(&quot;%.5lf\\n&quot;,query(x,y)); } }","path":"2018/06/26/BZOJ2402-陶陶的难题II/"},{"title":"斜率优化","text":"作用： 将某些复杂度不对的dp方程降一个维度，譬如O（n^2）的dp方程，若其满足决策单调性，既可通过斜率优化对其进行降维打击，让它强行变成O（n）的。 #决策单调性： 若对于fif_if​i​​来说，选择k这个决策是最优的，那么对于fi+1f_{i+1}f​i+1​​到fnf_nf​n​​来说，选择k之前的决策不会比选择k更优。例如：若f具有决策单调性fi+1f_{i+1}f​i+1​​的决策一定是k或在k后面的决策。 【证明决策单调性】： 【数学归纳法】： 设fi=min(fj+ai−aj)f_i=min(f_j+a_i-a_j)f​i​​=min(f​j​​+a​i​​−a​j​​) 假设有两个决策j和k,k&gt;j且k优于j fk+ai−ak&lt;fj+ai−ajf_k+a_i-a_k&lt;f_j+a_i-a_jf​k​​+a​i​​−a​k​​&lt;f​j​​+a​i​​−a​j​​ fk−ak&lt;fj−ajf_k-a_k&lt;f_j-a_jf​k​​−a​k​​&lt;f​j​​−a​j​​ 那么对于fi+1f_{i+1}f​i+1​​来说选择kkk即fi+1=fk+ai+1−akf_{i+1}=f_k+a_{i+1}-a_kf​i+1​​=f​k​​+a​i+1​​−a​k​​ 而选择jjj的话即fi+1=fj+ai+1−ajf_{i+1}=f_j+a_{i+1}-a_jf​i+1​​=f​j​​+a​i+1​​−a​j​​ 因为第444行的式子，对于fi+1f_{i+1}f​i+1​​选择k明显比选择j更优，同理fi+2f_i+2f​i​​+2可通过fi+1f_{i+1}f​i+1​​得到，那么，可既可说这个dp方程具有决策单调性。 斜率优化： 举例子说明总是比较直观的，下面我们来看一道例题。 【题目】: 现在我们有一个序列aaa，我们能把序列aaa切成若干段，对于在iii和jjj被断开的一段序列，既ai..ja_{i..j}a​i..j​​，我们可以得到一个分数∑k=ijak\\sum_{k=i}^j a_k∑​k=i​j​​a​k​​。我们在i位置切割一次，就会得到cic_ic​i​​的分数。那么对于整个序列a，我们希望它的总分最小，求这个分数和。 【n2n^2n​2​​做法】: 显然，我们能得到一个效率为n2n^2n​2​​的dp方程 我们先设 sumk=∑i=1kaisum_k=\\sum_{i=1}^ka_i sum​k​​=​i=1​∑​k​​a​i​​ fi=min(fj+(simi−sumj)2+ci)f_i=min(f_j+(sim_i-sum_j)^2+c_i) f​i​​=min(f​j​​+(sim​i​​−sum​j​​)​2​​+c​i​​) 若n≤105n\\leq10^5n≤10​5​​那么这个复杂度不能令人满意，我们就要接着对他进行一些处理。 【证明决策单调性】 若k&gt;jk&gt; jk&gt;j且kkk优于jjj fj+(sumi−sumj)2+ci&gt;fk+(sumi−sumk)2+cif_j+(sum_i-sum_j)^2+c_i&gt;f_k+(sum_i-sum_k)^2+c_i f​j​​+(sum​i​​−sum​j​​)​2​​+c​i​​&gt;f​k​​+(sum​i​​−sum​k​​)​2​​+c​i​​ fj+sumi2−2×sumi×sumj+sumj2+ci&gt;fk+sumi2−2×sumi×sumk+sumk2+cif_j+sum_i^2-2\\times sum_i\\times sum_j+sum_j^2+c_i&gt;f_k+sum_i^2-2\\times sum_i\\times sum_k+sum_k^2+c_i f​j​​+sum​i​2​​−2×sum​i​​×sum​j​​+sum​j​2​​+c​i​​&gt;f​k​​+sum​i​2​​−2×sum​i​​×sum​k​​+sum​k​2​​+c​i​​ fj−2×sumi×sumj+sumj2&gt;fk−2×sumi∗sumk+sumk2f_j-2\\times sum_i\\times sum_j+sum_j^2&gt;f_k-2\\times sum_i*sum_k+sum_k^2 f​j​​−2×sum​i​​×sum​j​​+sum​j​2​​&gt;f​k​​−2×sum​i​​∗sum​k​​+sum​k​2​​ 那么对于fi+1f_{i+1}f​i+1​​来说: 选择j为决策既：fi+1=fj+(sumi+1−sumj)2+ci+1f_{i+1}=f_j+(sum_{i+1}-sum_j)^2+c_{i+1}f​i+1​​=f​j​​+(sum​i+1​​−sum​j​​)​2​​+c​i+1​​ 选择k为决策既：fi+1=fk+(sumi+1−sumk)2+ci+1f_{i+1}=f_k+(sum_{i+1}-sum_k)^2+c_{i+1}f​i+1​​=f​k​​+(sum​i+1​​−sum​k​​)​2​​+c​i+1​​ 从上面的式子可以得到选择k优于选择j（不信的话可以自己展开） 那么可以证明这个dp方程式具有决策单调性的。 【推导斜率式】 fj−2×sumi×sumj+sumj2&gt;fk−2×sumi∗sumk+sumk2f_j-2\\times sum_i\\times sum_j+sum_j^2&gt;f_k-2\\times sum_i*sum_k+sum_k^2 f​j​​−2×sum​i​​×sum​j​​+sum​j​2​​&gt;f​k​​−2×sum​i​​∗sum​k​​+sum​k​2​​ 从这条式子继续 fj−fk+sumj2−sumk2&gt;2×sumi∗(sumj−sumk)f_j-f_k+sum_j^2-sum_k^2&gt;2\\times sum_i*(sum_j-sum_k) f​j​​−f​k​​+sum​j​2​​−sum​k​2​​&gt;2×sum​i​​∗(sum​j​​−sum​k​​) fj−fk+sumj2−sumk2sumj−sumk&gt;2∗sumi\\frac{f_j-f_k+sum_j^2-sum_k^2}{sum_j-sum_k}&gt;2*sum_i ​sum​j​​−sum​k​​​​f​j​​−f​k​​+sum​j​2​​−sum​k​2​​​​&gt;2∗sum​i​​ 根据这条式子的定义，我们可以得到，对于k&gt;jk&gt;jk&gt;j，只有在满足上面式子的情况下才会k比j优 我们把(fj+sumj2,sumj)(f_j+sum_j^2,sum_j)(f​j​​+sum​j​2​​,sum​j​​)和(fk+sumk2,sumk)(f_k+sum_k^2,sum_k)(f​k​​+sum​k​2​​,sum​k​​)分别看做坐标系上面的点，那么小于号左边的式子的含义恰好是这两个点之间的斜率。 现在我们假设找到了一个点(x,y)对于fif_if​i​​最优。我们在x点上画一条斜率为2∗sumi2*sum_i2∗sum​i​​的斜线，那么，对于其他所有点，都必须在这条斜线上方。 证明：若(a,b)(a,b)(a,b)在斜线下方，且a&lt;xa&lt;xa&lt;x那么根据上面的式子(a,b)(x,y)(a,b)(x,y)(a,b)(x,y)之间的斜率会大于2×sumi2\\times sum_i2×sum​i​​并且a&lt;xa&lt;xa&lt;x，那么(x,y)则不是最优点。若(a,b)在斜线下方，且a&gt;xa&gt;xa&gt;x那么根据上面的式子(a,b)(x,y)(a,b)(x,y)(a,b)(x,y)之间的斜率会小于2×sumi2\\times sum_i2×sum​i​​并且a&gt;xa&gt;xa&gt;x，那么(x,y)则不是最优点。 换句话说，对于fif_if​i​​来说，最优解x是斜率k=2∗sumik=2*sum_ik=2∗sum​i​​从下往上扫扫到点集里最优的那个点。 显然，我们可以得到一个很显然的结论，那就是这个最优解x在下凸壳上。那么我们可以通过一个队列来维护凸包，并且根据决策单调性，还有fj−fk+sumj2−sumk2sumj−sumk&gt;2∗sumi\\frac{f_j-f_k+sum_j^2-sum_k^2}{sum_j-sum_k}&gt;2*sum_i​sum​j​​−sum​k​​​​f​j​​−f​k​​+sum​j​2​​−sum​k​2​​​​&gt;2∗sum​i​​这条斜率式，我们可以每次比对下凸壳上相邻的两个点（也就是队首元素），若队列中第二个元素比队首元素优，那么我们可以删除队首元素（决策单调性，队首元素再也用不到）。 我们注意到，对于点i来说，他的横坐标是sumisum_isum​i​​,因为sumisum_isum​i​​是前缀和，是递增的，所以加入的点的横坐标也是递增的，那么对于每个点，我们只要把它加入维护凸包的那个队列就好了。 【某些不得不说的东西】： 最后我们推出来的式子一般都是长这样： x与j和k有关，y与j和k有关并且递增 xy\\frac{x}{y}​y​​x​​&lt;或&gt;只与i有关并且递增的常数 如果右边的与i有关的常数不是递增的，那意味着我们要扫的答案的斜率不是递增的，那么决策单调性就会消失，我们就要用平衡树或者三分去维护。所以一般，正常，好写的斜率优化最后推出来的式子一般都形如上面那条√","path":"2018/06/24/斜率优化/"},{"title":"杜教筛","text":"​ 我不会什么狄利克雷卷积，但同我反演只用∑d∣nμ(d)=(n==1)\\sum_{d|n}\\mu(d)=(n==1)∑​d∣n​​μ(d)=(n==1)这条式子一样，我觉得杜教筛也是相似的。 例题1： ​ ∑i=1nμ(i)\\sum_{i=1}^{n}\\mu(i)∑​i=1​n​​μ(i)范围：n≤1010n\\le10^{10}n≤10​10​​ 题解： ​ 引入式子∑d∣nμ(d)==(n==1)\\sum_{d|n}\\mu(d)==(n==1)∑​d∣n​​μ(d)==(n==1) ：这条以及后文引入的两条式子可在莫比乌斯反演那篇博文里看到证明 ​ 考虑μ(n)\\mu(n)μ(n)：μ(n)=(n==1)−∑d∣n&amp;d&lt;nμ(d)\\mu(n)=(n==1)-\\sum_{d|n\\&amp;d&lt;n}\\mu(d)μ(n)=(n==1)−∑​d∣n&amp;d&lt;n​​μ(d) ​ 那么将μ(n)\\mu(n)μ(n)代入原式 ​ ∑i=1nμ(i)\\sum_{i=1}^n\\mu(i)∑​i=1​n​​μ(i) ​ =∑i=1n((i==1)−∑d∣i&amp;d&lt;iμ(d))=\\sum_{i=1}^n((i==1)-\\sum_{d|i\\&amp;d&lt;i}\\mu(d))=∑​i=1​n​​((i==1)−∑​d∣i&amp;d&lt;i​​μ(d)) ​ =1−∑i=1n∑d∣i&amp;d&lt;iμ(d)=1-\\sum_{i=1}^n\\sum_{d|i\\&amp;d&lt;i } \\mu(d)=1−∑​i=1​n​​∑​d∣i&amp;d&lt;i​​μ(d) ​ 那么，对于μ(d)\\mu(d)μ(d)来说，它只有在d|i且d ​ 换句话说，μ(d)\\mu(d)μ(d)会在xd≤nxd\\le nxd≤n时被计算上（x&gt;1x&gt;1x&gt;1） ​ 那么我们枚举xxx ​ 原式既等于 ​ =1−∑x=2n∑xd&lt;=nμ(d)=1-\\sum_{x=2}^n\\sum_{xd&lt;=n}\\mu(d)=1−∑​x=2​n​​∑​xd&lt;=n​​μ(d) ​ =1−∑x=2n∑d=1⌊nx⌋μ(d)=1-\\sum_{x=2}^n\\sum_{d=1}^{\\lfloor\\frac{n}{x}\\rfloor}\\mu(d)=1−∑​x=2​n​​∑​d=1​⌊​x​​n​​⌋​​μ(d) ​ 稍微换一下符号 ​ =1−∑x=2n∑i=1⌊nx⌋μ(i)=1-\\sum_{x=2}^{n}\\sum_{i=1}^{\\lfloor\\frac{n}{x}\\rfloor}\\mu(i)=1−∑​x=2​n​​∑​i=1​⌊​x​​n​​⌋​​μ(i) ​ 然后我们发现 ​ woc右边那一块式子怎么那么熟悉（∑i=1⌊nx⌋μ(i)\\sum_{i=1}^{\\lfloor\\frac{n}{x}\\rfloor}\\mu(i)∑​i=1​⌊​x​​n​​⌋​​μ(i)） ​ 就好像……，就好像最开始要求的那样 ​ 那么我们设最开始的为一个函数： f(n)=∑i=1nμ(i)=1−∑x=2n∑i=1⌊nx⌋μ(i)=1−∑x=2nf(⌊nx⌋)f(n)=\\sum_{i=1}^n\\mu(i)=1-\\sum_{x=2}^{n}\\sum_{i=1}^{\\lfloor\\frac{n}{x}\\rfloor}\\mu(i)=1-\\sum_{x=2}^nf(\\lfloor\\frac{n}{x}\\rfloor)f(n)=∑​i=1​n​​μ(i)=1−∑​x=2​n​​∑​i=1​⌊​x​​n​​⌋​​μ(i)=1−∑​x=2​n​​f(⌊​x​​n​​⌋) ​ 那么，总共有根号不同的对于每个f(n)f(n)f(n)来说，我们最多要求根号级别的f(⌊nx⌋)f(\\lfloor\\frac{n}{x}\\rfloor)f(⌊​x​​n​​⌋) ​ 预处理前n23n^{\\frac{2}{3}}n​​3​​2​​​​的fff,然后记忆化搜索即可（后面的f的函数值用哈希表来存（或者map，不过多一个log）） 例题2： ​ Φ(i)=∑i=1nφ(i)\\Phi(i)=\\sum_{i=1}^{n}\\varphi(i)Φ(i)=∑​i=1​n​​φ(i)范围：n≤1010n\\le10^{10}n≤10​10​​ 题解： 引入： ∑d∣nφ(d)=n\\sum_{d|n}\\varphi(d)=n∑​d∣n​​φ(d)=n ​ φ(n)=n−∑d∣n&amp;d&lt;nφ(d)\\varphi(n)=n-\\sum_{d|n\\&amp;d&lt;n}\\varphi(d)φ(n)=n−∑​d∣n&amp;d&lt;n​​φ(d) ​ 原式=∑i=1n(i−∑d∣ni&amp;d&lt;iφ(i))\\sum_{i=1}^n(i-\\sum_{d|ni\\&amp;d&lt;i}\\varphi(i))∑​i=1​n​​(i−∑​d∣ni&amp;d&lt;i​​φ(i)) ​ 枚举dx对数 Φ(n)=n×(n+1)2−∑x=2n∑dx&lt;=nφ(d)\\Phi(n)=\\frac{n\\times(n+1)}{2}-\\sum_{x=2}^n\\sum_{dx&lt;=n}\\varphi(d) Φ(n)=​2​​n×(n+1)​​−​x=2​∑​n​​​dx&lt;=n​∑​​φ(d) =n×(n+1)2−∑x=2n∑d=1⌊nx⌋φ(d)=\\frac{n\\times(n+1)}{2}-\\sum_{x=2}^n\\sum_{d=1}^{\\lfloor\\frac{n}{x}\\rfloor}\\varphi(d) =​2​​n×(n+1)​​−​x=2​∑​n​​​d=1​∑​⌊​x​​n​​⌋​​φ(d) =n×(n+1)2−∑x=2n∑i=1⌊nx⌋φ(i)=\\frac{n\\times(n+1)}{2}-\\sum_{x=2}^n\\sum_{i=1}^{\\lfloor\\frac{n}{x}\\rfloor}\\varphi(i) =​2​​n×(n+1)​​−​x=2​∑​n​​​i=1​∑​⌊​x​​n​​⌋​​φ(i) =n×(n+1)2−∑x=2n∑i=1⌊nx⌋φ(i)=\\frac{n\\times(n+1)}{2}-\\sum_{x=2}^n\\sum_{i=1}^{\\lfloor\\frac{n}{x}\\rfloor}\\varphi(i) =​2​​n×(n+1)​​−​x=2​∑​n​​​i=1​∑​⌊​x​​n​​⌋​​φ(i) =n×(n+1)2−∑x=2nΦ(⌊nx⌋)=\\frac{n\\times(n+1)}{2}-\\sum_{x=2}^n\\Phi(\\lfloor\\frac{n}{x}\\rfloor) =​2​​n×(n+1)​​−​x=2​∑​n​​Φ(⌊​x​​n​​⌋) ​ 记忆化搜索即可 复杂度分析：不会，大概调一下预处理的参数，别的博客上面证明是O(n23)O(n^{\\frac{2}{3}})O(n​​3​​2​​​​)左右。 核心：乱推式子+记忆化搜索 筛phi的前缀和的模板 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;map&gt; #define MOD (1000000007) #define N 2500000 using namespace std; int p[N],prime[N],phi[N],tot; long long f[N]; map&lt;long long,long long&gt;l; int pre(){ phi[1]=1; for(int i=2;i&lt;=N-10;i++){ if(p[i]==0){ prime[++tot]=i; phi[i]=i-1; } for(int j=1;j&lt;=tot&amp;&amp;i*prime[j]&lt;=N-10;j++){ p[i*prime[j]]=1; phi[iprime[j]]=phi[i]phi[prime[j]]; if(i%prime[j]==0){ phi[iprime[j]]=phi[i]prime[j]; break; } } } } long long dfs(long long x){ if(x&lt;=N-10)return f[x]; if(l[x]!=0)return l[x]; long long ans=0; for(long long i=2;i&lt;=x;i++){ long long j=x/(x/i),k=(x/i); (ans=ans+dfs(k)*(j-i+1))%=MOD; i=j; } int k=x%MOD; l[x]=(1LLk(k+1)/2-ans%MOD)%MOD; return l[x]; } int main(){ pre(); long long n; scanf(&quot;%lld&quot;,&amp;n); for(long long i=1;i&lt;=N-10;i++)(f[i]=0LL+f[i-1]+phi[i])%MOD; printf(&quot;%lld&quot;,dfs(n)%MOD); }","path":"2018/06/24/杜教筛/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post $ hexo new &quot;My New Post&quot; More info: Writing Run server $ hexo server More info: Server Generate static files $ hexo generate More info: Generating Deploy to remote sites $ hexo deploy More info: Deployment","path":"2018/06/23/hello-world/"}]}