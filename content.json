{"pages":[],"posts":[{"title":"斜率优化","text":"斜率优化 #作用： 将某些复杂度不对的dp方程降一个维度，譬如O（n^2）的dp方程，若其满足决策单调性，既可通过斜率优化对其进行降维打击，让它强行变成O（n）的。 #决策单调性： 若对于$f_i$来说，选择k这个决策是最优的，那么对于$f_{i+1}$到$f_n$来说，选择k之前的决策不会比选择k更优。例如：若f具有决策单调性$f_{i+1}$的决策一定是k或在k后面的决策。 【证明决策单调性】： 【数学归纳法】： 设fi=min(fj+ai−aj)f_i=min(f_j+a_i-a_j)f​i​​=min(f​j​​+a​i​​−a​j​​) 假设有两个决策j和k,k&gt;j且k优于j fk+ai−ak&lt;fj+ai−ajf_k+a_i-a_k&lt;f_j+a_i-a_jf​k​​+a​i​​−a​k​​&lt;f​j​​+a​i​​−a​j​​ fk−ak&lt;fj−ajf_k-a_k&lt;f_j-a_jf​k​​−a​k​​&lt;f​j​​−a​j​​ 那么对于fi+1f_{i+1}f​i+1​​来说选择kkk即fi+1=fk+ai+1−akf_{i+1}=f_k+a_{i+1}-a_kf​i+1​​=f​k​​+a​i+1​​−a​k​​ 而选择jjj的话即fi+1=fj+ai+1−ajf_{i+1}=f_j+a_{i+1}-a_jf​i+1​​=f​j​​+a​i+1​​−a​j​​ 因为第444行的式子，对于fi+1f_{i+1}f​i+1​​选择k明显比选择j更优，同理fi+2f_i+2f​i​​+2可通过fi+1f_{i+1}f​i+1​​得到，那么，可既可说这个dp方程具有决策单调性。 斜率优化： 举例子说明总是比较直观的，下面我们来看一道例题。 【题目】: 现在我们有一个序列aaa，我们能把序列aaa切成若干段，对于在iii和jjj被断开的一段序列，既ai..ja_i..ja​i​​..j，我们可以得到一个分数(∑k=ijak)2(\\sum_{k=i}^ja_k)^2(∑​k=i​j​​a​k​​)​2​​。我们在i位置切割一次，就会得到cic_ic​i​​的分数。那么对于整个序列a，我们希望它的总分最小，求这个分数和。 【n2n^2n​2​​做法】: 显然，我们能得到一个效率为n2n^2n​2​​的dp方程 我们先设 sum_k=\\sum_{i=1}^ka_i$$ $$f_i=min(f_j+(sum_i-sum_j)^2+c_i)$$ ##### 若$n\\leq10^5$那么这个复杂度不能令人满意，我们就要接着对他进行一些处理。 ## 【证明决策单调性】 ##### 若$k> j$且$k$优于$j$ ##### $f_j+(sum_i-sum_j)^2+c_i>f_k+(sum_i-sum_k)^2+c_i$ $$f_j+sum_i^2-2\\times sum_i\\times sum_j+sum_j^2+c_i>f_k+sum_i^2-2\\times sum_i\\times sum_k+sum_k^2+c_i$$ $$f_j-2\\times sum_i\\times sum_j+sum_j^2>f_k-2\\times sum_i*sum_k+sum_k^2$$ ##### 那么对于$f_NaN$来说: ##### 选择j为决策既：$f_NaN=f_j+(sum_{i+1}-sum_j)^2+c_{i+1}$ ##### 选择k为决策既：$f_{i+1}=f_k+(sum_{i+1}-sum_k)^2+c_{i+1}$ ##### 从上面的式子可以得到选择k优于选择j（不信的话可以自己展开） ##### 那么可以证明这个dp方程式具有决策单调性的。 ## 【推导斜率式】 $$f_j-2\\times sum_i\\times sum_j+sum_j^2>f_k-2\\times sum_i*sum_k+sum_k^2 从这条式子继续 fj−fk+sumj2−sumk2&gt;2×sumi∗(sumj−sumk)f_j-f_k+sum_j^2-sum_k^2&gt;2\\times sum_i*(sum_j-sum_k) f​j​​−f​k​​+sum​j​2​​−sum​k​2​​&gt;2×sum​i​​∗(sum​j​​−sum​k​​) \\frac{f_j-f_k+sum_j^2-sum_k^2}{sum_j-sum_k}>2*sum_i$$ ##### 根据这条式子的定义，我们可以得到，对于$k>j$，只有在满足上面式子的情况下才会k比j优 ##### 我们把$(f_j+sum_j^2,sum_j)$和$(f_k+sum_k^2,sum_k)$分别看做坐标系上面的点，那么小于号左边的式子的含义恰好是这两个点之间的斜率。 ##### 现在我们假设找到了一个点(x,y)对于$f_i$最优。我们在x点上画一条斜率为$2*sum_i$的斜线，那么，对于其他所有点，都必须在这条斜线上方。 ##### 证明：若$(a,b)$在斜线下方，且$ax$，那么(x,y)则不是最优点。 ![](http://images2017.cnblogs.com/blog/1216492/201708/1216492-20170810195252824-1523165336.png) ##### 换句话说，对于$f_i$来说，最优解x是斜率$k=2*sum_i$从下往上扫扫到点集里最优的那个点。 ##### 显然，我们可以得到一个很显然的结论，那就是这个最优解x在下凸壳上。那么我们可以通过一个队列来维护凸包，并且根据决策单调性，还有$\\frac{f_j-f_k+sum_j^2-sum_k^2}{sum_j-sum_k}>2*sum_i$这条斜率式，我们可以每次比对下凸壳上相邻的两个点（也就是队首元素），若队列中第二个元素比队首元素优，那么我们可以删除队首元素（决策单调性，队首元素再也用不到）。 ##### 我们注意到，对于点i来说，他的横坐标是$sum_i$,因为$sum_i​$是前缀和，是递增的，所以加入的点的横坐标也是递增的，那么对于每个点，我们只要把它加入维护凸包的那个队列就好了。 # 【某些不得不说的东西】： ##### 最后我们推出来的式子一般都是长这样： ##### $\\frac{上边一些与j和k相关的元素}{下边一些与j和k相关的递增的元素，注意，是递增}只与i有关并且递增的常数$ ##### 如果右边的与i有关的常数不是递增的，那意味着我们要扫的答案的斜率不是递增的，那么决策单调性就会消失，我们就要用平衡树或者三分去维护。所以一般，正常，好写的斜率优化最后推出来的式子一般都形如上面那条√","path":"2018/06/24/斜率优化/"},{"title":"杜教筛","text":"杜教筛 ​ 我不会什么狄利克雷卷积，但同我反演只用∑d∣nμ(d)=(n==1)\\sum_{d|n}\\mu(d)=(n==1)∑​d∣n​​μ(d)=(n==1)这条式子一样，我觉得杜教筛也是相似的。 例题1： ​ ∑i=1nμ(i)\\sum_{i=1}^{n}\\mu(i)∑​i=1​n​​μ(i)范围：n≤1010n\\le10^{10}n≤10​10​​ 题解： ​ 引入式子∑d∣nμ(d)==(n==1)\\sum_{d|n}\\mu(d)==(n==1)∑​d∣n​​μ(d)==(n==1) ：这条以及后文引入的两条式子可在莫比乌斯反演那篇博文里看到证明 ​ 考虑μ(n)\\mu(n)μ(n)：μ(n)=(n==1)−∑d∣n&amp;d&lt;nμ(d)\\mu(n)=(n==1)-\\sum_{d|n\\&amp;d&lt;n}\\mu(d)μ(n)=(n==1)−∑​d∣n&amp;d&lt;n​​μ(d) ​ 那么将μ(n)\\mu(n)μ(n)代入原式 ​ ∑i=1nμ(i)\\sum_{i=1}^n\\mu(i)∑​i=1​n​​μ(i) ​ =∑i=1n((i==1)−∑d∣i&amp;d&lt;iμ(d))=\\sum_{i=1}^n((i==1)-\\sum_{d|i\\&amp;d&lt;i}\\mu(d))=∑​i=1​n​​((i==1)−∑​d∣i&amp;d&lt;i​​μ(d)) ​ =1−∑i=1n∑d∣i&amp;d&lt;iμ(d)=1-\\sum_{i=1}^n\\sum_{d|i\\&amp;d&lt;i } \\mu(d)=1−∑​i=1​n​​∑​d∣i&amp;d&lt;i​​μ(d) ​ 那么，对于μ(d)\\mu(d)μ(d)来说，它只有在d|i且d ​ 换句话说，μ(d)\\mu(d)μ(d)会在xd≤nxd\\le nxd≤n时被计算上（x&gt;1x&gt;1x&gt;1） ​ 那么我们枚举xxx ​ 原式既等于 ​ =1−∑x=2n∑xd&lt;=nμ(d)=1-\\sum_{x=2}^n\\sum_{xd&lt;=n}\\mu(d)=1−∑​x=2​n​​∑​xd&lt;=n​​μ(d) ​ =1−∑x=2n∑d=1⌊nx⌋μ(d)=1-\\sum_{x=2}^n\\sum_{d=1}^{\\lfloor\\frac{n}{x}\\rfloor}\\mu(d)=1−∑​x=2​n​​∑​d=1​⌊​x​​n​​⌋​​μ(d) ​ 稍微换一下符号 ​ =1−∑x=2n∑i=1⌊nx⌋μ(i)=1-\\sum_{x=2}^{n}\\sum_{i=1}^{\\lfloor\\frac{n}{x}\\rfloor}\\mu(i)=1−∑​x=2​n​​∑​i=1​⌊​x​​n​​⌋​​μ(i) ​ 然后我们发现 ​ woc右边那一块式子怎么那么熟悉（∑i=1⌊nx⌋μ(i)\\sum_{i=1}^{\\lfloor\\frac{n}{x}\\rfloor}\\mu(i)∑​i=1​⌊​x​​n​​⌋​​μ(i)） ​ 就好像……，就好像最开始要求的那样 ​ 那么我们设最开始的为一个函数： f(n)=∑i=1nμ(i)=1−∑x=2n∑i=1⌊nx⌋μ(i)=1−∑x=2nf(⌊nx⌋)f(n)=\\sum_{i=1}^n\\mu(i)=1-\\sum_{x=2}^{n}\\sum_{i=1}^{\\lfloor\\frac{n}{x}\\rfloor}\\mu(i)=1-\\sum_{x=2}^nf(\\lfloor\\frac{n}{x}\\rfloor)f(n)=∑​i=1​n​​μ(i)=1−∑​x=2​n​​∑​i=1​⌊​x​​n​​⌋​​μ(i)=1−∑​x=2​n​​f(⌊​x​​n​​⌋) ​ 那么，总共有根号不同的对于每个f(n)f(n)f(n)来说，我们最多要求根号级别的f(⌊nx⌋)f(\\lfloor\\frac{n}{x}\\rfloor)f(⌊​x​​n​​⌋) ​ 预处理前n23n^{\\frac{2}{3}}n​​3​​2​​​​的fff,然后记忆化搜索即可（后面的f的函数值用哈希表来存（或者map，不过多一个log）） 例题2： ​ Φ(i)=∑i=1nφ(i)\\Phi(i)=\\sum_{i=1}^{n}\\varphi(i)Φ(i)=∑​i=1​n​​φ(i)范围：n≤1010n\\le10^{10}n≤10​10​​ 题解： 引入： ∑d∣nφ(d)=n\\sum_{d|n}\\varphi(d)=n∑​d∣n​​φ(d)=n ​ φ(n)=n−∑d∣n&amp;d&lt;nφ(d)\\varphi(n)=n-\\sum_{d|n\\&amp;d&lt;n}\\varphi(d)φ(n)=n−∑​d∣n&amp;d&lt;n​​φ(d) ​ 原式=∑i=1n(i−∑d∣ni&amp;d&lt;iφ(i))\\sum_{i=1}^n(i-\\sum_{d|ni\\&amp;d&lt;i}\\varphi(i))∑​i=1​n​​(i−∑​d∣ni&amp;d&lt;i​​φ(i)) ​ 枚举dx对数 Φ(n)=n×(n+1)2−∑x=2n∑dx&lt;=nφ(d)\\Phi(n)=\\frac{n\\times(n+1)}{2}-\\sum_{x=2}^n\\sum_{dx&lt;=n}\\varphi(d) Φ(n)=​2​​n×(n+1)​​−​x=2​∑​n​​​dx&lt;=n​∑​​φ(d) =n×(n+1)2−∑x=2n∑d=1⌊nx⌋φ(d)=\\frac{n\\times(n+1)}{2}-\\sum_{x=2}^n\\sum_{d=1}^{\\lfloor\\frac{n}{x}\\rfloor}\\varphi(d) =​2​​n×(n+1)​​−​x=2​∑​n​​​d=1​∑​⌊​x​​n​​⌋​​φ(d) =n×(n+1)2−∑x=2n∑i=1⌊nx⌋φ(i)=\\frac{n\\times(n+1)}{2}-\\sum_{x=2}^n\\sum_{i=1}^{\\lfloor\\frac{n}{x}\\rfloor}\\varphi(i) =​2​​n×(n+1)​​−​x=2​∑​n​​​i=1​∑​⌊​x​​n​​⌋​​φ(i) =n×(n+1)2−∑x=2n∑i=1⌊nx⌋φ(i)=\\frac{n\\times(n+1)}{2}-\\sum_{x=2}^n\\sum_{i=1}^{\\lfloor\\frac{n}{x}\\rfloor}\\varphi(i) =​2​​n×(n+1)​​−​x=2​∑​n​​​i=1​∑​⌊​x​​n​​⌋​​φ(i) =n×(n+1)2−∑x=2nΦ(⌊nx⌋)=\\frac{n\\times(n+1)}{2}-\\sum_{x=2}^n\\Phi(\\lfloor\\frac{n}{x}\\rfloor) =​2​​n×(n+1)​​−​x=2​∑​n​​Φ(⌊​x​​n​​⌋) ​ 记忆化搜索即可 复杂度分析：不会，大概调一下预处理的参数，别的博客上面证明是O(n23)O(n^{\\frac{2}{3}})O(n​​3​​2​​​​)左右。 核心：乱推式子+记忆化搜索 筛phi的前缀和的模板 #include&lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;map&gt; #define MOD (1000000007) #define N 2500000 using namespace std; int p[N],prime[N],phi[N],tot; long long f[N]; map&lt;long long,long long&gt;l; int pre(){ phi[1]=1; for(int i=2;i&lt;=N-10;i++){ if(p[i]==0){ prime[++tot]=i; phi[i]=i-1; } for(int j=1;j&lt;=tot&amp;&amp;i*prime[j]&lt;=N-10;j++){ p[i*prime[j]]=1; phi[iprime[j]]=phi[i]phi[prime[j]]; if(i%prime[j]==0){ phi[iprime[j]]=phi[i]prime[j]; break; } } } } long long dfs(long long x){ if(x&lt;=N-10)return f[x]; if(l[x]!=0)return l[x]; long long ans=0; for(long long i=2;i&lt;=x;i++){ long long j=x/(x/i),k=(x/i); (ans=ans+dfs(k)*(j-i+1))%=MOD; i=j; } int k=x%MOD; l[x]=(1LLk(k+1)/2-ans%MOD)%MOD; return l[x]; } int main(){ pre(); long long n; scanf(&quot;%lld&quot;,&amp;n); for(long long i=1;i&lt;=N-10;i++)(f[i]=0LL+f[i-1]+phi[i])%MOD; printf(&quot;%lld&quot;,dfs(n)%MOD); }","path":"2018/06/24/杜教筛/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post $ hexo new &quot;My New Post&quot; More info: Writing Run server $ hexo server More info: Server Generate static files $ hexo generate More info: Generating Deploy to remote sites $ hexo deploy More info: Deployment","path":"2018/06/23/hello-world/"}]}